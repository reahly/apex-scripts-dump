global function ClWeaponStatus_Init
global function ClWeaponStatus_GetWeaponHudRui
global function ClWeaponStatus_RefreshWeaponStatus
global function ClWeaponStatus_UpdateShowButtonHint
global function ClWeaponStatus_RefreshWeaponInfo

global function AddCallback_OnInitWeaponStatusRuis
global function AddCallback_OnWeaponStatusUpdate
global function AddCallback_OnPrimaryWeaponStatusUpdate
global function AddCallback_ShouldShowChargeBar

global function AddModToTableOfPassiveWeaponBonuses

global function TrackPrimaryWeaponEnabled

global function GetHudDefaultVisibility
global function WeaponStatusSetWeaponInspect
global function WeaponStatusSetDeathBoxMenuOpen
global function UltimateWeaponStateSet
global function UpdateHudDataForMainWeapons
global function GetLastSelectedPrimaryWeapon
global function ServerCallback_UpdateHudWeaponData
global function ServerCallback_UpdateOffhandRuis

global function NotifyReloadAttemptButNoReserveAmmo

global function UpdateWeaponStatusOnBindingChange

global function SetFiringModeIndicatorColorOverrides
global function OnSelectedWeaponChanged

global function GetUltimateWeaponState

#if(DEV)
global function DEV_TestUltimateStates
#endif //

global enum eUltimateState
{
	CHARGING    //
	READY        //
	ACTIVE        //
}

struct PassiveWeaponBonusData
{
	string                     nameText
	string                     descText
	string                     altDescText
	asset                      icon
	bool functionref( entity ) shouldShowAltDescTextFunc
}

struct
{
	var    ammo_status_hint
	var    ability_left_hud
	var    ability_center_hud
	var    ability_right_hud
	var    weapon_hud_rui
	int    ultimateVideoChannel
	entity lastSelectedPrimaryWeapon

	bool[6] slotVisible = [true, true, true, true, true, true]
	bool    ammo_counter_visible = true

	array<void functionref( entity, var, int )> weaponStatusUpdateCallbacks
	array<void functionref( entity, var )>      primaryWeaponStatusUpdateCallbacks
	array<bool functionref( entity, var )>      shouldChargeBarShowCallbacks

	table< string, PassiveWeaponBonusData > passiveWeaponBonusMods
	table< string, float >                  haveShownBonusPopupTimestamp

	array<vector> firingModeIndicatorColorOverrides

	#if(DEV)
		bool devTestingUltimateStates
	#endif //
} file

const float NO_RESERVE_AMMO_DISPLAY_TIME = 2.0

void function ClWeaponStatus_Init()
{
	AddCallback_OnClientScriptInit( ClWeaponStatus_AddClient )
	AddCallback_OnSelectedWeaponChanged( OnSelectedWeaponChanged )

	AddCallback_OnPlayerLifeStateChanged( OnLifeStateChanged )
	AddCallback_PlayerClassChanged( OnPlayerClassChanged )

	AddCallback_OnPlayerAddWeaponMod( OnPlayerAddWeaponMod )
	AddCallback_OnPlayerRemoveWeaponMod( OnPlayerRemoveWeaponMod )

	AddCallback_KillReplayEnded( OnKillReplayEnded )

	AddCallback_OnCommsMenuStateChanged( AmmoStatusHint_OnCommsMenu )

	AddCallback_OnSettingsUpdated( UpdateHudDataForCurrentActiveWeapon )

	if ( GetCurrentPlaylistVarBool( "hud_ultimate_ready_video", false ) )
	{
		AddCallback_OnWeaponStatusUpdate( UltimateWeaponStatusUpdate )
		RegisterSignal( "ultimate_video_finished" )
		file.ultimateVideoChannel = ReserveVideoChannel( UltimateReadyVideoFinished )
	}

	RegisterSignal( "EndTrackOffhandWeaponSlot" )
	RegisterSignal( "ultimate_weapon_status_changed" )
}


void function UpdateWeaponStatusOnBindingChange()
{
	bool weaponSelectKeysBound = GetKeyCodeForBinding( "weaponSelectPrimary0", 0 ) != -1 && GetKeyCodeForBinding( "weaponSelectPrimary1", 0 ) != -1
	var weaponRui              = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( weaponRui != null )
		RuiSetBool( weaponRui, "weaponSelectKeysBoundForPC", weaponSelectKeysBound )
}


void function AddCallback_OnPrimaryWeaponStatusUpdate( void functionref( entity, var ) func )
{
	Assert( !file.primaryWeaponStatusUpdateCallbacks.contains( func ) )
	file.primaryWeaponStatusUpdateCallbacks.append( func )
}


void function AddCallback_ShouldShowChargeBar( bool functionref( entity, var ) func )
{
	Assert( !file.shouldChargeBarShowCallbacks.contains( func ) )
	file.shouldChargeBarShowCallbacks.append( func )
}


void function AddCallback_OnWeaponStatusUpdate( void functionref( entity, var, int ) func )
{
	Assert( !file.weaponStatusUpdateCallbacks.contains( func ) )
	file.weaponStatusUpdateCallbacks.append( func )
}


void function AddModToTableOfPassiveWeaponBonuses( string modName, string nameText, string descText, asset icon, string altDescText = "", bool functionref( entity ) func = null )
{
	PassiveWeaponBonusData data
	data.nameText = nameText
	data.descText = descText
	data.altDescText = altDescText
	data.shouldShowAltDescTextFunc = func == null ? bool function( entity weapon ){ return false } : func
	data.icon = icon

	if ( altDescText != "" )
		Assert( func != null, "Must specificy alt text function if alt text is specified" )

	file.passiveWeaponBonusMods[ modName ] <- data
}


void function ClWeaponStatus_RefreshWeaponStatus( entity player )
{
	if ( !IsValid( player ) )
		return

	if ( !IsValid( GetLocalViewPlayer() ) )
		return

	InitWeaponStatusRuis( GetLocalViewPlayer() )
}


var function ClWeaponStatus_GetWeaponHudRui( entity player, entity weapon = null )
{
	if ( weapon == null )
		return file.weapon_hud_rui

	var index = weapon.GetWeaponInfoFileKeyField( "offhand_default_inventory_slot" )
	//

	if ( index == null )
		return file.weapon_hud_rui

	expect int( index )

	return GetRuiForIndex( player, index )
}


void function ClWeaponStatus_AddClient( entity player )
{
	{
		var rui = CreateCockpitPostFXRui( $"ui/ammo_status_hint.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "ammoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
		RuiTrackFloat( rui, "remainingAmmoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
		RuiTrackFloat( rui, "readyToFireFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
		RuiTrackFloat( rui, "reloadingFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_RELOAD_FRACTION )
		RuiTrackFloat( rui, "minAmmoToFireFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_CLIP_MIN_AMMO_FRACTION )
		RuiTrackBool( rui, "canShowReloadHint", null, RUI_TRACK_CAN_SHOW_RELOAD_PROMPT )

		file.ammo_status_hint = rui
	}

	{
		//
		var rui = CreateCockpitPostFXRui( $"ui/tactical_ability_hud.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		RuiTrackFloat( rui, "silencedTimeRemaining", player, RUI_TRACK_STATUS_EFFECT_TIME_REMAINING, eStatusEffect.silenced )
		RuiSetFloat( rui, "silenceEffectDuration", Silence_GetEffectDuration() )
		file.ability_center_hud = rui
	}

	{
		//
		var rui
		if ( GetCurrentPlaylistVarBool( "hud_ultimate_ready_video", false ) )
			rui = CreateCockpitPostFXRui( $"ui/ultimate_ability_hud.rpak", HUD_Z_BASE )
		else
			rui = CreateCockpitPostFXRui( $"ui/ability_hud.rpak", HUD_Z_BASE )

		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		file.ability_left_hud = rui
	}

	{
		//
		var rui = CreateCockpitRui( $"ui/ability_hud.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		file.ability_right_hud = rui
	}

	{
		var rui = CreateCockpitPostFXRui( SURVIVAL_HUD_WEAPON_RUI, HUD_Z_BASE )
		//
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		file.weapon_hud_rui = rui
		UpdateWeaponStatusOnBindingChange()
	}
}


void function ClWeaponStatus_RefreshWeaponInfo()
{
	//
	UpdateHudDataForMainWeapons( GetLocalViewPlayer(), null )
}


void function UpdateHudDataForCurrentActiveWeapon()
{
	entity activeWeapon = GetLocalViewPlayer().GetLatestPrimaryWeaponForIndexZeroOrOne( eActiveInventorySlot.mainHand )
	UpdateHudDataForMainWeapons( GetLocalViewPlayer(), activeWeapon )
}


bool function IsWeaponInPrimarySlot( entity player, entity weapon )
{
	entity weaponInSlot0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	entity weaponInSlot1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )

	bool isInPrimarySlot = IsValid( weapon ) && (weapon == weaponInSlot0 || weapon == weaponInSlot1)
	return isInPrimarySlot
}


void function NotifyReloadAttemptButNoReserveAmmo()
{
	RuiSetFloat( file.ammo_status_hint, "displayNoReserveAmmoEndTime", Time() + NO_RESERVE_AMMO_DISPLAY_TIME )
}


void function OnSelectedWeaponChanged( entity selectedWeapon )
{
	entity player = GetLocalViewPlayer()

	if ( !IsValid( selectedWeapon ) )
	{
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )
		RuiSetBool( file.weapon_hud_rui, "isVisible", false )
		return
	}

	if ( selectedWeapon.IsWeaponOffhand() )
	{
		RuiSetBool( file.weapon_hud_rui, "isMainWeaponSelected", false )
		bool isOffhandUsesAmmoStatus = selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )

		if ( !isOffhandUsesAmmoStatus )
			return
	}

	UpdateHudDataForMainWeapons( player, selectedWeapon )
	UpdateDpadHud( player )

	foreach ( func in file.primaryWeaponStatusUpdateCallbacks )
		func( selectedWeapon, file.weapon_hud_rui )


	bool showChargeBar = false
	foreach ( func in file.shouldChargeBarShowCallbacks )
	{
		if ( func( selectedWeapon, file.weapon_hud_rui ) )
		{
			showChargeBar = true
			break
		}
	}

	if ( !showChargeBar )
	{
		RuiSetBool( file.weapon_hud_rui, "showChargeBar", false )
	}
}


void function AmmoStatusHint_OnCommsMenu( bool menuOpened )
{
	//
	RuiSetVisible( file.ammo_status_hint, !menuOpened )
}


void function ServerCallback_UpdateOffhandRuis()
{
	entity player = GetLocalViewPlayer()

	if ( !IsValid( player ) )
		return

	UpdateOffhandRuis( player )
	thread TrackOffhandWeaponSlot( player, file.ability_center_hud, OFFHAND_LEFT )
	thread TrackOffhandWeaponSlot( player, file.ability_left_hud, OFFHAND_INVENTORY )
}


void function ServerCallback_UpdateHudWeaponData( entity weaponFromServer )
{
	entity player = GetLocalViewPlayer()
	if ( IsValid( weaponFromServer ) && weaponFromServer.GetWeaponClassName() == "mp_ability_crypto_drone" )
	{
		TrackCryptoAnimatedTacticalRuiOffhandWeapon()
		return
	}

	entity weapon = player.GetSelectedWeapon( eActiveInventorySlot.mainHand )
	if ( !IsValid( weapon ) )
		weapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
	UpdateHudDataForMainWeapons( player, weapon )
}


void function UpdateHudDataForMainWeapons( entity player, entity selectedWeapon )
{
	var rui = file.weapon_hud_rui

	bool isOffhandUsesAmmoStatus = IsValid( selectedWeapon ) && selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )
	bool isTurret = IsValid( selectedWeapon) && GetWeaponInfoFileKeyField_GlobalInt_WithDefault( selectedWeapon.GetWeaponClassName(), "is_turret_weapon" , 0 ) == 1

	entity weaponInSlot0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	entity weaponInSlot1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )
	bool noWeapon        = !IsValid( weaponInSlot0 ) && !IsValid( weaponInSlot1 ) && !isOffhandUsesAmmoStatus && !isTurret
	bool isMainWeapon    = IsValid( selectedWeapon ) && (selectedWeapon == weaponInSlot0 || selectedWeapon == weaponInSlot1)
	bool isTitan         = player.IsTitan()

	if ( noWeapon || isTitan )
	{
		ClearRuiWeaponData( rui, isTitan )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )    //
		return
	}

	if ( !isOffhandUsesAmmoStatus )
	{
		RuiSetBool( rui, "noMainWeaponEquiped", false )
		RuiSetBool( rui, "isMainWeaponSelected", isMainWeapon )
	}

	//

	int activeWeaponTab = -1

	if ( isMainWeapon )
	{
		//
		if ( selectedWeapon == weaponInSlot0 && IsValid( weaponInSlot0 ) )
			activeWeaponTab = 0
		if ( selectedWeapon == weaponInSlot1 && IsValid( weaponInSlot1 ) )
			activeWeaponTab = 1
	}
	else if( IsValid( file.lastSelectedPrimaryWeapon ) )
	{
		//
		//
		if ( IsValid( weaponInSlot0 ) && file.lastSelectedPrimaryWeapon == weaponInSlot0 )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot0 )
			activeWeaponTab = 0
		}
		else if ( IsValid( weaponInSlot1 ) && file.lastSelectedPrimaryWeapon == weaponInSlot1  )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot1 )
			activeWeaponTab = 1
		}
	}
	else
	{
		//
		if ( IsValid( weaponInSlot0 ) )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot0 )
			file.lastSelectedPrimaryWeapon = weaponInSlot0
			activeWeaponTab = 0
		}
		else if ( IsValid( weaponInSlot1 ) )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot1 )
			file.lastSelectedPrimaryWeapon = weaponInSlot1
			activeWeaponTab = 1
		}
	}

	if (!isTurret)
	{
		UpdateRUIWeaponData( player, rui, weaponInSlot0, 0, activeWeaponTab == 0 )
		UpdateRUIWeaponData( player, rui, weaponInSlot1, 1, activeWeaponTab == 1 )

		RuiSetString ( rui, "weaponSwitchOverride", "" )
	}
	else
	{
		ClearRuiWeaponData( rui, false )

		RuiSetBool( rui, "isMainWeaponSelected", true )
		RuiSetBool( rui, "noMainWeaponEquiped", false )

		activeWeaponTab = 1
		UpdateRUIWeaponData( player, rui, selectedWeapon, 0, false )
		UpdateRUIWeaponData( player, rui, selectedWeapon, 1, true )

		RuiSetString( rui, "weaponNameTab0", "#WPN_MOUNTED_TURRET_WEAPON_RELEASE" )
		RuiSetFloat3( rui, "ammoColorTab0", <0.1, 0.1, 0.1> )
		RuiSetFloat3( rui, "ammoColorTab1", <0.8, 0.1, 0.8> )

		if ( IsControllerModeActive() )
			RuiSetString( rui, "weaponSwitchOverride", "%&weaponCycle%" )
		else
			RuiSetString( rui, "weaponSwitchOverride", "%&use%" )

		RuiSetImage( rui, "ammoIcon", $"rui/hud/gametype_icons/survival/sur_ammo_rampart_hmg" )
		RuiSetFloat3( rui, "ammoColor", <0.8, 0.1, 0.8> )
		RuiSetImage( rui, "hudIcon", selectedWeapon.GetWeaponSettingAsset( eWeaponVar.hud_icon ) )

		InitWeaponRuiTracks( rui, player, selectedWeapon )
	}

	if ( isMainWeapon )
	{
		InitWeaponRuiTracks( rui, player, selectedWeapon )
		file.lastSelectedPrimaryWeapon = selectedWeapon

		float lowAmmoFrac = selectedWeapon.GetWeaponSettingFloat( eWeaponVar.low_ammo_fraction )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", lowAmmoFrac )

		bool canShowWeaponCycleHint = CanShowWeaponCycleHint( selectedWeapon, weaponInSlot0, weaponInSlot1 )
		RuiSetBool( file.ammo_status_hint, "canShowWeaponCycleHint", canShowWeaponCycleHint )

		bool canShowReloadHint = CanShowReloadHint()
		RuiSetBool( file.ammo_status_hint, "canShowReloadHint", canShowReloadHint )
	}
	else if ( isOffhandUsesAmmoStatus )
	{
		float lowAmmoFrac = selectedWeapon.GetWeaponSettingFloat( eWeaponVar.low_ammo_fraction )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", lowAmmoFrac )
	}
	else
	{
		//
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )

		//
		if ( IsWeaponInPrimarySlot( player, file.lastSelectedPrimaryWeapon ) && !isTurret )
			UpdateModsOnSurvivalWeaponRui( rui, file.lastSelectedPrimaryWeapon )
	}
}


entity function GetLastSelectedPrimaryWeapon()
{
	return file.lastSelectedPrimaryWeapon
}

void function ClearRuiWeaponData( var rui, bool isTitan )
{
	RuiSetInt( rui, "sightTier", 0 )
	RuiSetBool( rui, "sightAllowed", false )
	RuiSetInt( rui, "barrelTier", 0 )
	RuiSetBool( rui, "barrelAllowed", false )
	RuiSetInt( rui, "magTier", 0 )
	RuiSetBool( rui, "magAllowed", false )
	RuiSetInt( rui, "gripTier", 0 )
	RuiSetBool( rui, "gripAllowed", false )
	RuiSetInt( rui, "hopupTier", 0 )
	RuiSetBool( rui, "hopupAllowed", false )
	RuiSetInt( rui, "hopupMultiATier", 0 )
	RuiSetBool( rui, "hopupMultiAAllowed", false )
	RuiSetInt( rui, "hopupMultiBTier", 0 )
	RuiSetBool( rui, "hopupMultiBAllowed", false )
	RuiSetInt( rui, "hopupLootIdx", -1 )
	RuiSetBool( rui, "showPassiveBonusPopup", false )
	RuiSetInt( rui, "weaponTier", 0 )

	RuiSetFloat( rui, "maxMagAmmo", 0 )
	RuiSetFloat( rui, "maxAmmo", 0 )
	RuiSetFloat( rui, "clipAmmoFrac", 0 )
	RuiSetFloat( rui, "remainingAmmoFrac", 0 )
	RuiSetFloat( rui, "lifetimeShots", 0 )
	RuiSetFloat( rui, "ammoRegenRate", 0 )

	RuiSetBool( rui, "ammoPoolVisible", false )

	RuiSetImage( rui, "hudIcon", $"" )

	RuiSetFloat3( rui, "ammoColor", SrgbToLinear( <0.5, 0.5, 0.5> ) )
	RuiSetImage( rui, "ammoIcon", $"rui/hud/gametype_icons/survival/sur_ammo_blank" )
	RuiSetFloat3( rui, "borderDefaultColor", SrgbToLinear( <0.5, 0.5, 0.5> ) )
	RuiSetInt( rui, "attachmentLockPips", 0 )

	RuiSetInt( rui, "selectedWeaponLootIdx", -1 )
	RuiSetInt( rui, "weaponTabSelected", -1 )
	RuiSetBool( rui, "isMainWeaponSelected", false )
	RuiSetBool( rui, "noMainWeaponEquiped", true )
	RuiSetString( rui, "weaponSwitchOverride", "" )
	RuiSetString( rui, "weaponNameTab0", "" )
	RuiSetString( rui, "weaponNameTab1", "" )

	ClearWeaponToggleHUD()

	RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && file.ammo_counter_visible && !isTitan) )
}


void function UpdateRUIWeaponData( entity player, var rui, entity weapon, int tabIndex, bool selected )
{
	LootData weaponData = SURVIVAL_GetLootDataFromWeapon( weapon )

	if ( selected )
	{
		PrimaryWeapon_UpdateFireSelectHUD( weapon )
		UpdateModsOnSurvivalWeaponRui( rui, weapon )

		RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && file.ammo_counter_visible && !player.IsTitan()) )
		RuiSetBool( rui, "isTitan", player.IsTitan() )
		RuiSetBool( rui, "isWeaponAmped", weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) )

		RuiSetInt( rui, "weaponTabSelected", tabIndex )
		RuiSetString( rui, "skinName", "" )
		RuiSetInt( rui, "skinTier", 0 )
	}

	if ( IsValid( weapon ) )
	{
		string weaponName = GetWeaponInfoFileKeyField_GlobalString( weapon.GetWeaponClassName(), "shortprintname" )
		RuiSetString( rui, "weaponNameTab" + tabIndex, weaponName )
		if ( selected )
			RuiSetString( rui, "weaponName", weaponName )

		if ( SURVIVAL_Loot_IsRefValid( weaponData.ref ) )
		{
			if ( selected )
			{
				RuiSetInt( rui, "weaponTier", weaponData.tier )
				RuiSetInt( rui, "selectedWeaponLootIdx", weaponData.index )

				if ( weaponName != "" )
				{
					if ( weaponData.lootType == eLootType.MAINWEAPON && weapon.GetGrade() > 0 )
					{
						ItemFlavor weaponSkin = GetItemFlavorByNetworkIndex_DEPRECATED( weapon.GetGrade() )
						RuiSetString( rui, "skinName", ItemFlavor_GetLongName( weaponSkin ) )
						if ( ItemFlavor_HasQuality( weaponSkin ) )
							RuiSetInt( rui, "skinTier", ItemFlavor_GetQuality( weaponSkin ) + 1 )
					}
				}
			}

			vector ammoColor = SrgbToLinear( <0.5, 0.5, 0.5> )
			vector rarityColor = SrgbToLinear( <0.3, 0.3, 0.3> ) //
			asset ammoIcon   = weaponData.fakeAmmoIcon == $"" ? $"rui/hud/gametype_icons/survival/sur_ammo_unique" : weaponData.fakeAmmoIcon
			bool isCrateWeapon = ( weaponData.tier == eLootTier.HEIRLOOM )
			bool isAttachmentLocked =  SURVIVAL_Weapon_IsAttachmentLocked( weaponData.ref )
			RuiSetInt( rui, "weaponTier", weaponData.tier )

			if ( ( weaponData.tier == eLootTier.COMMON ) && isAttachmentLocked )
				rarityColor = SrgbToLinear( GetKeyColor( COLORID_FRAME_LOOT_TIER1 ) / 255.0 )
			else if ( weaponData.tier == eLootTier.RARE )
				rarityColor = SrgbToLinear( GetKeyColor( COLORID_FRAME_LOOT_TIER2 ) / 255.0 )
			else if ( weaponData.tier == eLootTier.EPIC )
				rarityColor = SrgbToLinear( GetKeyColor( COLORID_FRAME_LOOT_TIER3 ) / 255.0 )
			else if ( weaponData.tier == eLootTier.LEGENDARY )
				rarityColor = SrgbToLinear( GetAmmoColorByType( "legendary" ) )
			else if ( weaponData.tier == eLootTier.HEIRLOOM )
			{
				rarityColor = SrgbToLinear( GetAmmoColorByType( "supply_drop" ) )
				ammoColor = rarityColor
			}

			if ( weaponData.ammoType != "" )
			{
				LootData ammoData = SURVIVAL_Loot_GetLootDataByRef( weaponData.ammoType )
				ammoColor = SrgbToLinear( GetAmmoColorByType( weaponData.ammoType ) )

				if ( ammoData.hudIcon != $"" )
					ammoIcon = ammoData.hudIcon
			}

			RuiSetFloat3( rui, "ammoColorTab" + tabIndex, ammoColor )
			if ( selected )
			{
				RuiSetFloat3( rui, "borderDefaultColor", rarityColor )
				RuiSetInt( rui, "attachmentLockPips", isAttachmentLocked && !( weaponData.tier == eLootTier.HEIRLOOM ) ? weaponData.tier : 0 )
				RuiSetFloat3( rui, "rarityColor", rarityColor )
				RuiSetFloat3( rui, "ammoColor", ammoColor )
				RuiSetFloat3( rui, "ammoGlowColor", isAttachmentLocked ? rarityColor : ammoColor )
				RuiSetImage( rui, "ammoIcon", ammoIcon )
			}
		}
	}
	else
	{
		RuiSetString( rui, "weaponNameTab" + tabIndex, "" )
		RuiSetFloat3( rui, "ammoColorTab" + tabIndex, <0.0, 0.0, 0.0> )
		if ( selected )
		{
			RuiSetImage( rui, "ammoIcon", $"" )
			RuiSetFloat3( rui, "ammoColor", <0.0, 0.0, 0.0> )
		}
	}
}


void function PrimaryWeapon_UpdateFireSelectHUD( entity weapon )
{
	if ( !IsValid( weapon ) )
	{
		ClearWeaponToggleHUD()
		return
	}

	//
	if ( WeaponHasFireModeSelect( weapon ) )
	{
		int currentFireModeIndex = GetWeaponCurrentFireModeIndex( weapon )

		if ( IsWeaponInSingleShotMode( weapon ) )
		{
                  
                                                        
     
                                                     
                                                                                                                        
         
                                                                                                                                     
     
       
      
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_shot", "#FIRE_MODE_SINGLE", 2, currentFireModeIndex )
		}
		else if ( IsWeaponInBurstMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/burst", "#FIRE_MODE_BURST", 2, currentFireModeIndex )
		}
		else if ( IsWeaponInAutomaticMode( weapon ) )
		{
                               
                                                                     
    
                                     
                                                                                                                                    
        
                                                                                                         
    
       
      
                 
			if ( DoesModExist( weapon, "hopup_paintball" ) && IsModActive( weapon, "hopup_paintball" ) )
			{
				if ( currentFireModeIndex == 0 )
				{
					SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_PAINT_01", 3, currentFireModeIndex, true )
				}
				else if ( currentFireModeIndex == 1 )
				{
					SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_PAINT_02", 3, currentFireModeIndex, true )
				}
				else if ( currentFireModeIndex == 2 )
				{
					SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_PAINT_03", 3, currentFireModeIndex, true )
				}
				else if ( currentFireModeIndex == 3 )
				{
					SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_PAINT_04", 3, currentFireModeIndex, true )
				}
			}
			else
      
			{
				SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_AUTO", 2, currentFireModeIndex )
			}
		}
		else
		{
			ClearWeaponToggleHUD()
		}
	}
	//
	else if ( DoesModExist( weapon, "vertical_firestar" ) )
	{
		if ( weapon.HasMod( "vertical_firestar" ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/akimbo", "#FIRE_MODE_LINE", 2 )
		}
		else
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_gun", "#FIRE_MODE_WALL", 2 )
		}
	}
	else if ( DoesModExist( weapon, "double_link_mod" ) )
	{
		if ( weapon.HasMod( "double_link_mod" ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/akimbo", "#FIRE_MODE_SPLIT", 2 )
		}
		else
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_gun", "#FIRE_MODE_COMBINED", 2 )
		}
	}
                         
                                             
  
                                  
   
                                                                                
   
      
   
                                                                                    
   
  
      
                           
                                            
  
                                                                                                         

                                        
                                                                                                         
      
                                                                                                     
  
      
	else if ( weapon.HasMod( "hopup_energy_choke" ) )
	 {
		 if ( weapon.HasMod( "choke" ) )
			 SetWeaponToggleHUD( $"rui/hud/weapon_toggle/choke_enabled", "#ENERGY_CHOKE_ENABLED", 2, 0 )
		 else
			 SetWeaponToggleHUD( $"rui/hud/weapon_toggle/choke_disabled", "#ENERGY_CHOKE_DISABLED", 2, 1 )
	 }
	else
	{
		if ( IsWeaponInSingleShotMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_shot", "#FIRE_MODE_SINGLE_ONLY", 1 )
		}
		else if ( IsWeaponInBurstMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/burst", "#FIRE_MODE_BURST_ONLY", 1 )
		}
		else if ( IsWeaponInAutomaticMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_AUTO_ONLY", 1 )
		}
		else
		{
			ClearWeaponToggleHUD()
		}
	}
}


const table<string, string> ruiAttachmentAllowedArgs = {
	barrel = "barrelAllowed"
	grip = "gripAllowed"
	mag = "magAllowed"
	sight = "sightAllowed"
	hopup = "hopupAllowed"
	hopupMulti_a = "hopupMultiAAllowed"
	hopupMulti_b = "hopupMultiBAllowed"
}

const table<string, string> ruiAttachmentTierArgs = {
	barrel = "barrelTier"
	grip = "gripTier"
	mag = "magTier"
	sight = "sightTier"
	hopup = "hopupTier"
	hopupMulti_a = "hopupMultiATier"
	hopupMulti_b = "hopupMultiBTier"
}

const table<string, string> ruiAttachmentIconArgs = {
	barrel = "barrelIcon"
	grip = "gripIcon"
	mag = "magIcon"
	sight = "sightIcon"
	hopup = "hopupIcon"
	hopupMulti_a = "hopupMultiAIcon"
	hopupMulti_b = "hopupMultiAIcon"
}

void function UpdateModsOnSurvivalWeaponRui( var rui, entity weapon )
{
	LootData weaponData

	if ( weapon.GetNetworkedClassName() == "prop_survival" )
		weaponData = SURVIVAL_Loot_GetLootDataByIndex( weapon.GetSurvivalInt() )
	else
		weaponData = SURVIVAL_GetLootDataFromWeapon( weapon )

	string weaponRef = weaponData.ref
	bool isTurret = GetWeaponInfoFileKeyField_GlobalInt_WithDefault( weapon.GetWeaponClassName(), "is_turret_weapon" , 0 ) == 1

	if ( !SURVIVAL_Loot_IsRefValid( weaponData.ref ) )
	{
		array<string> attachments = GetAllAttachmentPoints()
		foreach ( attachmentName in attachments )
		{
			RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], false )
			RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], 0 )
			RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], $"" )
		}

		if ( !isTurret )
			return
	}

	array<string> attachments = GetAllAttachmentPoints()
	array<string> mods        = weapon.GetMods()

	bool isAttachmentLockedWeapon = SURVIVAL_Weapon_IsAttachmentLocked( weaponRef )

	bool hopupPopupSet = false
	if ( !isTurret )
	{
		foreach ( attachmentName in attachments )
		{
			Assert( attachmentName in ruiAttachmentAllowedArgs )
			Assert( attachmentName in ruiAttachmentTierArgs )
			Assert( attachmentName in ruiAttachmentIconArgs )

			if ( AttachmentPointSupported( attachmentName, weaponRef ) )
			{
				RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], true )

				string mod = GetInstalledWeaponAttachmentForPoint( weapon, attachmentName )
				if ( SURVIVAL_Loot_IsRefValid( mod ) )
				{
					LootData data = SURVIVAL_Loot_GetLootDataByRef( mod )
					if ( isAttachmentLockedWeapon )
						RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], weaponData.tier )
					else
						RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], data.tier )
					RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], data.hudIcon )

					if ( (attachmentName == "hopup" || attachmentName == "hopupMulti_a" || attachmentName == "hopupMulti_b") && DisplayHopupPopup() )
					{
						RuiSetInt( rui, "hopupLootIdx", data.index )
						RuiSetString( rui, "hopupName", Localize( data.pickupString ).toupper() )
						RuiSetString( rui, "hopupDesc", Localize( data.hopupPopupDesc ) )
						hopupPopupSet = true
					}
				}
				else
				{
					string attachmentStyle = GetAttachmentPointStyle( attachmentName, weaponRef )

					RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], 0 )
					RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], emptyAttachmentSlotImages[attachmentStyle] )
				}
			}
			else
			{
				RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], false )
				RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], $"" )
			}
		}
	}

	bool timeEligibleForBonusPopup = ! (weapon.GetWeaponClassName() in file.haveShownBonusPopupTimestamp) || Time() - file.haveShownBonusPopupTimestamp[ weapon.GetWeaponClassName() ] < 3.0
	if ( timeEligibleForBonusPopup && !hopupPopupSet && DisplayHopupPopup() )
	{
		foreach ( string modName in mods )
		{
			if ( modName in file.passiveWeaponBonusMods )
			{
				PassiveWeaponBonusData weaponInfo = file.passiveWeaponBonusMods[ modName ]

				RuiSetString( rui, "hopupName", Localize( weaponInfo.nameText ).toupper() )

				string descText = weaponInfo.shouldShowAltDescTextFunc( weapon ) ? weaponInfo.altDescText : weaponInfo.descText
				RuiSetString( rui, "hopupDesc", Localize( descText ) )

				string attachPoint = ""
				if ( SURVIVAL_Loot_IsRefValid( modName ) )
					attachPoint = GetAttachPointForAttachmentOnWeapon( weaponRef, modName )
				else
					attachPoint = "hopup"	//
				string hopupIconArg = ruiAttachmentIconArgs[attachPoint]
				string hopupTierArg = ruiAttachmentTierArgs[attachPoint]
				RuiSetImage( rui, hopupIconArg, weaponInfo.icon )
				RuiSetInt( rui, hopupTierArg, 1 )

				RuiSetBool( rui, "showPassiveBonusPopup", true )

				file.haveShownBonusPopupTimestamp[ weapon.GetWeaponClassName() ] <- Time()
				hopupPopupSet = true
			}
		}
	}

	if ( !hopupPopupSet )
	{
		RuiSetInt( rui, "hopupLootIdx", -1 )
		RuiSetBool( rui, "showPassiveBonusPopup", false )
	}
}


void function ClearWeaponToggleHUD()
{
	var rui = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( rui != null )
	{
		RuiSetString( rui, "fireMode", "" )
		RuiSetInt( rui, "numFireModes", 1 )
	}
}


bool function WeaponHasFireModeSelect( entity weapon )
{
	if ( DoesModExist( weapon, "hopup_selectfire" ) )
		return IsModActive( weapon, "hopup_selectfire" )
                      
	else if ( DoesModExist( weapon, "hopup_highcal_rounds" ) && IsModActive( weapon, "hopup_highcal_rounds" ) )
		return true
         
                  
                                                                                                    
             
         
                 
	else if ( DoesModExist( weapon, "hopup_paintball" ) && IsModActive( weapon, "hopup_paintball" ) )
		return true
         
                  
                                                           
             
      
	else if ( DoesModExist( weapon, "altfire" ) )
		return true

	return false
}


int function GetWeaponCurrentFireModeIndex( entity weapon )
{
                      
	if ( DoesModExist( weapon, "hopup_highcal_rounds" ) && IsModActive( weapon, "hopup_highcal_rounds" ) )
	{
		if ( IsModActive( weapon, "altfire_highcal" ) )
			return 1
		else
			return 0
	}
         
                  
                                                                                               
  
                                                    
           
      
           
  
         
                 
	if ( DoesModExist( weapon, "hopup_paintball" ) && IsModActive( weapon, "hopup_paintball" ) )
	{
		if ( IsModActive( weapon, "paintball_color01" ) )
		{
			return 0
		}
		else if ( IsModActive( weapon, "paintball_color02" ) )
		{
			return 1
		}
		else if ( IsModActive( weapon, "paintball_color03" ) )
		{
			return 2
		}
		else if ( IsModActive( weapon, "paintball_color_random" ) )
		{
			return 3
		}
		else
		{
			return -1
		}
	}
         
	if ( DoesModExist( weapon, "altfire" ) )
	{
		if ( IsModActive( weapon, "altfire" ) )
			return 1
		else
			return 0
	}

	return 0
}


void function SetWeaponToggleHUD( asset icon, string modeName, int numFireModes = 1, int currentFireModeIndex = 1, bool useCustomFireModeColors = false, vector customFireModeColors = <-1.0, -1.0, -1.0> )
{
	var rui = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( rui != null )
	{
		Assert( numFireModes > 0, "Cannot have 0 firing modes for a weapon in SetWeaponToggleHUD." )

		RuiSetInt( rui, "numFireModes", numFireModes )
		RuiSetString( rui, "fireMode", modeName )
		RuiSetImage( rui, "fireModeIcon", icon )
		RuiSetInt( rui, "currentFireModeIndex", currentFireModeIndex )

		if ( useCustomFireModeColors )
		{
			if ( customFireModeColors != <-1.0, -1.0, -1.0> )
			{
				RuiSetFloat3( rui, "firingMode0Color", customFireModeColors )
				RuiSetFloat3( rui, "firingMode1Color", customFireModeColors )
				RuiSetFloat3( rui, "firingMode2Color", customFireModeColors )
			}
			else
			{
				if ( file.firingModeIndicatorColorOverrides.len() > 2 )
				{
					RuiSetFloat3( rui, "firingMode0Color", file.firingModeIndicatorColorOverrides[0] )
					RuiSetFloat3( rui, "firingMode1Color", file.firingModeIndicatorColorOverrides[1] )
					RuiSetFloat3( rui, "firingMode2Color", file.firingModeIndicatorColorOverrides[2] )
				}
				else if ( file.firingModeIndicatorColorOverrides.len() > 1 )
				{
					RuiSetFloat3( rui, "firingMode0Color", file.firingModeIndicatorColorOverrides[0] )
					RuiSetFloat3( rui, "firingMode1Color", file.firingModeIndicatorColorOverrides[1] )
				}
				else if ( file.firingModeIndicatorColorOverrides.len() > 0 )
				{
					RuiSetFloat3( rui, "firingMode0Color", file.firingModeIndicatorColorOverrides[0] )
				}
			}
		}
		else
		{
			RuiSetFloat3( rui, "firingMode0Color", <1, 1, 1> )
			RuiSetFloat3( rui, "firingMode1Color", <1, 1, 1> )
			RuiSetFloat3( rui, "firingMode2Color", <1, 1, 1> )
		}
	}
}


void function UpdateFireSelectHint( entity player, entity weapon, string mod )
{
	string message = ""

	if ( IsWeaponInSingleShotMode( weapon ) )
	{
		message = "#FIRE_MODE_SINGLE"
	}
	else if ( IsWeaponInBurstMode( weapon ) )
	{
		message = "#FIRE_MODE_BURST"
	}
	else if ( IsWeaponInAutomaticMode( weapon ) )
	{
                               
                                                                    
   
                                    
                           
       
                               
   
      
      
		message = "#FIRE_MODE_AUTO"
	}

	if ( message != "" )
	{
		AnnouncementMessageRight( player, Localize( "#FIRE_MODE_COLON", Localize( message ) ), "", <1, 1, 1>, $"", 1.0 )
	}
}

void function UpdateChokeHint( entity player, entity weapon, string mod )
{
	string message = ""
	if ( weapon.HasMod( "choke" ) )
		message = "#ENERGY_CHOKE_ENABLED"
	else
		message = "#ENERGY_CHOKE_DISABLED"

	AnnouncementMessageRight( player, Localize( message ), "", <1, 1, 1>, $"", 1.0 )
}


void function OnPlayerAddWeaponMod( entity player, entity weapon, string mod )
{
	if ( mod == "altfire" || mod == "altfire_highcal" || mod == "altfire_double_tap" )
	{
		if ( WeaponHasFireModeSelect( weapon ) )
			UpdateFireSelectHint( player, weapon, mod )
	}
	if ( mod == "choke" )
	{
		UpdateChokeHint( player, weapon, mod )
	}
}


void function OnPlayerRemoveWeaponMod( entity player, entity weapon, string mod )
{
	if ( mod == "altfire" || mod == "altfire_highcal" || mod == "altfire_double_tap" )
	{
		if ( WeaponHasFireModeSelect( weapon ) )
			UpdateFireSelectHint( player, weapon, mod )
	}
	if ( mod == "choke" )
	{
		UpdateChokeHint( player, weapon, mod )
	}

	OnSelectedWeaponChanged( weapon )
}


bool function CanShowWeaponCycleHint( entity selectedWeapon, entity weaponInSlot0, entity weaponInSlot1 )
{
	if ( !IsValid( selectedWeapon ) )
		return false

	if ( selectedWeapon.ShouldAutoCycleWhenOutOfAmmo() )
		return false  //

	bool haveAnotherValidPrimary = ((IsValid( weaponInSlot0 ) && (selectedWeapon != weaponInSlot0)) || (IsValid( weaponInSlot1 ) && (selectedWeapon != weaponInSlot1)))
	if ( !haveAnotherValidPrimary )
		return false

	return true
}


bool function CanShowReloadHint()
{
	entity localViewPlayer = GetLocalViewPlayer()
	if ( !IsValid( localViewPlayer ) )
		return false

	int gamePadUseScheme = GetConVarInt( "gamepad_use_type" )
	entity useEnt        = localViewPlayer.GetUsePromptEntity()
	if ( (gamePadUseScheme == eGamepadUseSchemeType.TAP_TO_USE_TAP_TO_RELOAD) && IsValid( useEnt ) )
		return false

	if ( (gamePadUseScheme == eGamepadUseSchemeType.TAP_TO_USE_HOLD_TO_RELOAD) && IsValid( useEnt ) )
		return false

	return true
}


void function WeaponStatusSetWeaponInspect( bool inspect )
{
	RuiSetBool( file.ability_left_hud, "weaponInspect", inspect )
	RuiSetBool( file.ability_center_hud, "weaponInspect", inspect )
	RuiSetBool( file.ability_right_hud, "weaponInspect", inspect )
	RuiSetBool( file.weapon_hud_rui, "weaponInspect", inspect )
	array<var> additionalWeaponInspectRuis
	additionalWeaponInspectRuis.append( GetCryptoAnimatedTacticalRui() )
	additionalWeaponInspectRuis.append( GetBubbleBunkerRui() )
	foreach ( rui in additionalWeaponInspectRuis )
	{
		if ( rui != null )
			RuiSetBool( rui, "weaponInspect", inspect )
	}
}


void function WeaponStatusSetDeathBoxMenuOpen( bool isOpen )
{
	RuiSetBool( file.weapon_hud_rui, "isDeathBoxMenuOpen", isOpen )
}


void function InitWeaponRuiTracks( var rui, entity player, entity weapon )
{
	RuiTrackFloat( rui, "maxMagAmmo", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_MAX )
	RuiTrackFloat( rui, "maxAmmo", weapon, RUI_TRACK_WEAPON_AMMO_MAX )
	RuiTrackFloat( rui, "clipAmmoFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
	RuiTrackFloat( rui, "remainingAmmoFrac", weapon, RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
	RuiTrackFloat( rui, "lifetimeShots", weapon, RUI_TRACK_WEAPON_LIFETIME_SHOTS )
	RuiTrackFloat( rui, "ammoRegenRate", weapon, RUI_TRACK_WEAPON_AMMO_REGEN_RATE )
	RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )

	RuiSetBool( rui, "ammoPoolVisible", weapon.GetWeaponSettingBool( eWeaponVar.uses_ammo_pool ) )

	RuiTrackImage( rui, "hudIcon", weapon, RUI_TRACK_WEAPON_HUD_ICON )
}


void function OnPlayerClassChanged( entity player )
{
	if ( player != GetLocalViewPlayer() )
		return

	InitWeaponStatusRuis( player )
}


void function OnLifeStateChanged( entity player, int oldLifeState, int newLifeState )
{
	if ( player != GetLocalViewPlayer() )
		return

	if ( newLifeState != LIFE_ALIVE )
		return

	UltimateWeaponStateSet( eUltimateState.CHARGING )    //
	InitWeaponStatusRuis( player )
}


void function OnKillReplayEnded()
{
	entity player = GetLocalViewPlayer()

	InitWeaponStatusRuis( player )
}


void function UpdateOffhandRuis( entity player )
{
	UpdateOffhandRuiVisibility( file.ability_left_hud, "%offhand1%" )
	var cryptoTacticalRui = GetCryptoAnimatedTacticalRui()
	if ( cryptoTacticalRui != null )
		UpdateOffhandRuiVisibility( cryptoTacticalRui, "%offhand1%" )

	if ( !player.IsTitan() )
	{
		UpdateOffhandRuiVisibility( file.ability_center_hud, "%offhand0%" )
		UpdateOffhandRuiVisibility( file.ability_right_hud, "%offhand2%" )
	}

	//
	//
	//
	//
	//
	//
	//
}

array<void functionref( entity )> s_callbacks_OnInitWeaponStatusRuis
void function AddCallback_OnInitWeaponStatusRuis( void functionref( entity ) func )
{
	Assert( !s_callbacks_OnInitWeaponStatusRuis.contains( func ) )
	s_callbacks_OnInitWeaponStatusRuis.append( func )
}


void function InitWeaponStatusRuis( entity player )
{
	player.Signal( "EndTrackOffhandWeaponSlot" )

	foreach ( func in s_callbacks_OnInitWeaponStatusRuis )
		func( player )

	UpdateOffhandRuis( player )
	thread TrackPrimaryWeaponEnabled( player, file.ammo_status_hint, "EndTrackOffhandWeaponSlot" )

	if ( !player.IsTitan() )
	{
		thread TrackOffhandWeaponSlot( player, file.ability_center_hud, OFFHAND_LEFT )
		thread TrackOffhandWeaponSlot( player, file.ability_left_hud, OFFHAND_INVENTORY )
	}
}


void function UpdateOffhandRuiVisibility( var rui, string hintText )
{
	if ( GetConVarInt( "hud_setting_showButtonHints" ) != 0 )
		RuiSetString( rui, "hintText", hintText )
	else
		RuiSetString( rui, "hintText", "" )
}


void function TrackPrimaryWeaponEnabled( entity player, var rui, string endString )
{
	player.EndSignal( endString )
	player.EndSignal( "OnDeath" )

	while ( IsAlive( player ) )
	{
		bool weaponUsesAmmoStatus = false
		entity selectedWeapon     = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
		if ( IsValid( selectedWeapon ) )
			weaponUsesAmmoStatus = !player.IsUsingOffhandWeapon( eActiveInventorySlot.mainHand ) || selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )

		RuiSetBool( rui, "weaponIsUp", player.GetWeaponDisableFlags() != WEAPON_DISABLE_FLAGS_ALL && player.GetWeaponDisableFlags() != WEAPON_DISABLE_FLAGS_MAIN && weaponUsesAmmoStatus )
		WaitFrame()
	}
}


void function TrackOffhandWeaponSlot( entity player, var rui, int slot )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			RuiSetBool( rui, "isVisible", false )
		}
	)

	switch ( slot )
	{
		case OFFHAND_RIGHT:
			UpdateOffhandRuiVisibility( rui, "%offhand0%" )
			break

		case OFFHAND_LEFT:
			UpdateOffhandRuiVisibility( rui, "%offhand1%" )
			break

		case OFFHAND_TITAN_CENTER:
			UpdateOffhandRuiVisibility( rui, "%offhand2%" )
			break

		case OFFHAND_INVENTORY:
			if ( IsControllerModeActive() )
				UpdateOffhandRuiVisibility( rui, "%offhand1%+%ping%" )
			else
				UpdateOffhandRuiVisibility( rui, "%offhand4%" )
			break
	}

	entity lastWeapon = null
	bool wasVisible   = file.slotVisible[slot]
	while ( IsAlive( player ) )
	{
		entity weapon = player.GetOffhandWeapon( slot )
		if ( weapon != lastWeapon || file.slotVisible[slot] != wasVisible )
		{
			if ( IsValid( weapon ) && file.slotVisible[slot] )
			{
				thread InitOffhandRui( rui, player, weapon )
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
			}
		}

		switch ( slot )
		{
			case OFFHAND_INVENTORY:
				if ( IsControllerModeActive() )
					UpdateOffhandRuiVisibility( rui, "%offhand1%+%ping%" )
				else
					UpdateOffhandRuiVisibility( rui, "%offhand4%" )
				break

			case OFFHAND_LEFT:
				UpdateOffhandRuiVisibility( rui, "%offhand1%" )
				break
		}

		foreach ( func in file.weaponStatusUpdateCallbacks )
			func( player, rui, slot )

		lastWeapon = weapon
		wasVisible = file.slotVisible[slot]
		WaitFrame()
	}
}


void function UltimateWeaponStatusUpdate( entity player, var rui, int slot )
{
	//
	//
	//

	#if(DEV)
		if ( file.devTestingUltimateStates )
			return
	#endif //

	if ( slot != OFFHAND_ULTIMATE )
		return

	entity weapon = player.GetOffhandWeapon( OFFHAND_ULTIMATE )
	if ( !IsValid( weapon ) )
		return

	int maxClipCount = weapon.GetWeaponPrimaryClipCountMax()
	int clipCount    = weapon.GetWeaponPrimaryClipCount()

	bool ultimateReady = (clipCount >= maxClipCount)

	if ( ultimateReady && GetUltimateWeaponState() < eUltimateState.READY )
		UltimateWeaponStateSet( eUltimateState.READY )
	else if ( !ultimateReady && GetUltimateWeaponState() > eUltimateState.CHARGING && weapon.IsReadyToFire() )
		UltimateWeaponStateSet( eUltimateState.CHARGING )
	//
}


int currentUltimateState = eUltimateState.CHARGING
void function UltimateWeaponStateSet( int ultimateWeaponState )
{
	int lastUltimateState = currentUltimateState
	currentUltimateState = ultimateWeaponState

	if ( lastUltimateState == currentUltimateState )
		return

	Signal( clGlobal.levelEnt, "ultimate_weapon_status_changed" )

	switch( currentUltimateState )
	{
		case eUltimateState.CHARGING:
			UltimateWeaponStateCharging()
			break

		case eUltimateState.READY:
			UltimateWeaponStateReady()
			break

		case eUltimateState.ACTIVE:
			UltimateWeaponStateActive()
			break
	}
}


int function GetUltimateWeaponState()
{
	return currentUltimateState
}


void function UltimateWeaponStateCharging()
{
	RuiSetGameTime( file.ability_left_hud, "regenBeginTime", Time() )
}


void function UltimateWeaponStateReady()
{
	//
}


void function UltimateWeaponStateActive()
{
	RuiSetGameTime( file.ability_left_hud, "ultimateActivatedTime", Time() )
}


void function UltimateReadyVideoFinished( int channel )
{
	printt( "UltimateReadyVideoFinished" )
	Signal( clGlobal.levelEnt, "ultimate_video_finished" )
}

#if(DEV)
void function DEV_TestUltimateStates()
{
	thread DEV_TestUltimateStatesThread()
}

void function DEV_TestUltimateStatesThread()
{
	Assert ( IsNewThread(), "Must be threaded off." )

	file.devTestingUltimateStates = true

	UltimateWeaponStateSet( eUltimateState.CHARGING )
	wait 0.5
	UltimateWeaponStateSet( eUltimateState.READY )
	wait 5
	UltimateWeaponStateSet( eUltimateState.ACTIVE )
	wait 5
	UltimateWeaponStateSet( eUltimateState.CHARGING )

	wait 2
	file.devTestingUltimateStates = false
}
#endif //

/*














































































































*/

void function InitOffhandRui( var rui, entity player, entity weapon )
{
	Assert ( IsNewThread(), "Must be threaded off." )

	EndSignal( player, "OnDestroy" ) //
	EndSignal( weapon, "OnDestroy" )

	RuiSetGameTime( rui, "hintTime", Time() )

	RuiSetBool( rui, "isTitan", player.IsTitan() )
	RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && !player.IsTitan()) )
	RuiSetBool( rui, "isReverseCharge", false )
	bool isPaused = weapon.HasMod( "survival_ammo_regen_paused" )
	RuiSetBool( rui, "isPaused", isPaused )

	RuiSetFloat( rui, "chargeFrac", 0.0 )
	RuiSetFloat( rui, "useFrac", 0.0 )
	RuiSetFloat( rui, "chargeMaxFrac", 1.0 )
	RuiSetFloat( rui, "minFireFrac", 1.0 )
	RuiSetInt( rui, "segments", 1 )
	RuiTrackFloat( rui, "refillRate", weapon, RUI_TRACK_WEAPON_AMMO_REGEN_RATE )

	RuiTrackImage( rui, "hudIcon", weapon, RUI_TRACK_WEAPON_HUD_ICON )

	RuiTrackFloat( rui, "readyFrac", weapon, RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
	RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_DRYFIRE_FRACTION )

	RuiSetFloat( rui, "chargeFracCaution", 0.0 )
	RuiSetFloat( rui, "chargeFracAlert", 0.0 )
	RuiSetFloat( rui, "chargeFracAlertSpeed", 16.0 )
	RuiSetFloat( rui, "chargeFracAlertScale", 1.0 )

	RuiSetInt( rui, "ammoMinToFire", weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire ) )

	ItemFlavor character                    = LoadoutSlot_WaitForItemFlavor( ToEHI( player ), Loadout_Character() )
	CharacterHudUltimateColorData colorData = CharacterClass_GetHudUltimateColorData( character )

	RuiSetColorAlpha( rui, "ultimateColor", SrgbToLinear( colorData.ultimateColor ), 1 )
	RuiSetColorAlpha( rui, "ultimateColorHighlight", SrgbToLinear( colorData.ultimateColorHighlight ), 1 )

	switch ( weapon.GetWeaponSettingEnum( eWeaponVar.cooldown_type, eWeaponCooldownType ) )
	{
		case eWeaponCooldownType.ammo_timed:
		case eWeaponCooldownType.ammo_instant:
		case eWeaponCooldownType.ammo_deployed:
			RuiSetFloat( rui, "readyFrac", 0.0 )

		case eWeaponCooldownType.ammo:
			int maxAmmoReady = weapon.UsesClipsForAmmo() ? weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) : weapon.GetWeaponPrimaryAmmoCountMax( weapon.GetActiveAmmoSource() )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			if ( maxAmmoReady == 0 )
				maxAmmoReady = 1
			RuiSetFloat( rui, "minFireFrac", float( ammoMinToFire ) / float( maxAmmoReady ) )
			if ( ammoPerShot == 0 )
				ammoPerShot = 1
			RuiSetInt( rui, "segments", maxAmmoReady / ammoPerShot )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )

			RuiTrackFloat( rui, "useFrac", weapon, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.simple_timer )

			//
			break

		case eWeaponCooldownType.vortex_drain:
			RuiSetBool( rui, "isReverseCharge", true )
			RuiSetFloat( rui, "chargeFrac", 1.0 )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			break

		default:
			Assert( false, "Unsupported cooldown_type: " + weapon.GetWeaponSettingEnum( eWeaponVar.cooldown_type, eWeaponCooldownType ) )
	}
}


void function ClWeaponStatus_UpdateShowButtonHint()
{
	if ( file.weapon_hud_rui != null )
		RuiSetBool( file.weapon_hud_rui, "showButtonHints", ShouldShowButtonHints() )
}


var function GetRuiForIndex( entity player, int offhandIndex )
{
	var rui

	if ( player.IsTitan() )
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break

			case OFFHAND_TITAN_CENTER:
				rui = file.ability_center_hud
				break

			case OFFHAND_RIGHT:
				rui = file.ability_right_hud
				break
		}
	}
	else
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break

			case OFFHAND_RIGHT:
				rui = file.ability_center_hud
				break
		}
	}

	return rui
}


bool function GetHudDefaultVisibility()
{
	if ( Freelance_IsHubLevel() )
		return false
	return true
}


bool function IsWeaponInPrimarySlot2( entity player, entity weapon )
{
	if ( !IsValid( weapon ) )
		return false

	return weapon == player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_2 )
}


void function SetFiringModeIndicatorColorOverrides( array<vector> colorOverrides )
{
	file.firingModeIndicatorColorOverrides = colorOverrides
}