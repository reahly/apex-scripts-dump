global function ClMinimap_Init

global function ClientCodeCallback_MinimapEntitySpawned

global function Minimap_AddCustomLayer

global function RegisterDefaultMinimapPackage
global function RegisterMinimapPackage

global function CreateMinimapRui
global function Minimap_SetSizeScale
global function Minimap_IsUsingLargeMinimap
global function Minimap_SetBlankBackground
global function Minimap_SetNorthFacing
global function Minimap_UpdateNorthFacingOnSettingChange

global function Minimap_RingPulseAtLocation
global function ServerCallback_RingPulseMinimap

global function Minimap_EnableDraw
global function Minimap_DisableDraw
global function Minimap_DeathFieldEnableDraw
global function Minimap_DeathFieldDisableDraw

global function Minimap_UpdateMinimapVisibility
global function Minimap_UpdateShowButtonHint

global function Minimap_CommonAdd
global function Minimap_CommonCleanup
global function Minimap_CommonTrackEntOrigin

global function Minimap_AddEnemyToMinimap
global function Minimap_AddCryptoPulseToMinimap
global function Minimap_SetTintParams

global function Minimap_SetDeathFieldRadius

global function Fullmap_AddRui
global function Fullmap_AddTintableRui
global function Fullmap_RemoveRui
global function Fullmap_SetVisible
global function Fullmap_IsVisible
global function Fullmap_SetTintParams
global function UpdateFullmapRuiTracks
global function GetFullmapGamestateRui

global function SetMinimapBackgroundTileImage
global function GetMinimapBackgroundTileImage

global function SetMapFeatureItem
global function RemoveMapFeatureItemByName

global function MinimapObjectThread

global function Minimap_AddAssetCountLimit

global function MiniMapIsDisabled

global function UpdateEquipmentSlot

#if(DEV)
global function DEV_Minimap_DumpEntHandles
global function DEV_Minimap_DebugSurveyBeacons
#endif

global struct MapFeature
{
	string titleText
	string descDesc
	asset  icon

	int priority
}

struct {
	var minimap_base
	var minimap_frame
	var minimap_coords
	var minimap_wedges

	int activeMinimapObjectCount

	var minimap_you
	var minimap_jammed_layer

	var minimap_indicator

	#if(DEV)
		table<int, entity> minimapHandles
		table<entity, var> surveyBeaconEntsToRuis
	#endif

	array<var> minimapOtherRuis
	array<var> minimapPlayers
	array<var> fullmapRuis
	array<var> fullmapRuis_Tintable

	float threatMaxDist

	bool  minimapDoBlankBackground = false
	float minimapZoomScale = 1
	float minimapSizeScale = 1

	bool minimapEnabled = true
	bool fullmapVisible = false

	entity hack_playerAngleReplacement
	int    minimapDisableDrawStackCount
	asset  minimapBackgroundTileImage

	var        fullmap_legendRui
	array<var> fullmap_unitframesRui
	var        fullmap_gamestateRui

	array<var> fullmap_challengeRuiArray
	var fullmap_questBoxRui

	array<MapFeature> mapFeatureList

	array<asset> countLimitedAssets
	array<int>   countLimitedCounts
	array<int>   countLimitedMaxes
} file


struct MinmapPackage
{
	asset                           minimapAsset = $""
	void functionref( entity, var ) initFunction
	asset                           fullmapAsset = $""
	void functionref( entity, var ) fullmapInitFunction
}

table<string, array<MinmapPackage> > minimapAssetMap = {}

const int OF_IS_VISIBLE = 1 << 0
const int OF_TEAM_SAME = 1 << 1
const int OF_TEAM_ENEMY = 1 << 2
const int OF_IN_OUR_PARTY = 1 << 3
const int OF_IS_OWNED_BY_US = 1 << 4
const int OF_IS_PLAYER = 1 << 5
const int OF_IS_NPC = 1 << 6
const int OF_IS_TITAN = 1 << 7
const int OF_ORIENT_UP = 1 << 8
const int OF_NO_TEAM_COLOR = 1 << 9


void function RegisterMinimapPackage( string entityClassname, int customStateIndex, asset minimapAsset, void functionref( entity, var ) initFunction, asset fullmapAsset = $"", void functionref( entity, var ) fullmapInitFunction = null )
{
	Assert( (entityClassname in minimapAssetMap), "minimap is not currently setup to handle this type of entity: " + entityClassname )

	MinmapPackage minimapPackage
	minimapPackage.minimapAsset = minimapAsset
	minimapPackage.initFunction = initFunction
	minimapPackage.fullmapAsset = fullmapAsset
	minimapPackage.fullmapInitFunction = fullmapInitFunction

	switch ( entityClassname )
	{
		case "npc_soldier":
		case "npc_spectre":
		case "npc_stalker":
		case "npc_drone":
		case "npc_frag_drone":
		case "npc_super_spectre":
		case "npc_turret_sentry":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_npc.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_npc.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "npc_titan":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_npc_titan.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_npc_titan.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "prop_script":
		case "prop_loot_grabber":
		case "item_flag":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_prop_script.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_prop_script.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "info_hardpoint":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_info_hardpoint.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_info_hardpoint.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		default:
			Assert( false, "minimap is not currently setup to handle this type of entity: " + entityClassname )
	}
}


void function RegisterDefaultMinimapPackage( string entityClassname, asset minimapAsset, void functionref( entity, var ) initFunction, asset fullmapAsset = $"", void functionref( entity, var ) fullmapInitFunction = null )
{
	Assert( !(entityClassname in minimapAssetMap) )

	MinmapPackage minimapPackage
	minimapPackage.minimapAsset = minimapAsset
	minimapPackage.initFunction = initFunction
	minimapPackage.fullmapAsset = fullmapAsset
	minimapPackage.fullmapInitFunction = fullmapInitFunction

	minimapAssetMap[entityClassname] <- [minimapPackage]
}


void function ClMinimap_Init()
{
	RegisterDefaultMinimapPackage( "player", MINIMAP_PLAYER_RUI, MinimapPackage_PlayerInit )
	RegisterDefaultMinimapPackage( "npc_soldier", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_spectre", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_stalker", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_super_spectre", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_drone_rocket", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_frag_drone", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_drone", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_dropship", MINIMAP_OBJECT_RUI, MinimapPackage_NPCDropShipInit )
	RegisterDefaultMinimapPackage( "npc_turret_sentry", MINIMAP_OBJECT_RUI, MinimapPackage_NPCSentryTurretInit )
	RegisterDefaultMinimapPackage( "prop_script", $"", MinimapPackage_DummyInit )
	//
	RegisterDefaultMinimapPackage( "item_flag", MINIMAP_OBJECT_RUI, MinimapPackage_DummyInit )
	RegisterDefaultMinimapPackage( "item_bomb", MINIMAP_OBJECT_RUI, MinimapPackage_LTSBomb )
	RegisterDefaultMinimapPackage( "info_hardpoint", $"", MinimapPackage_DummyInit )
	RegisterDefaultMinimapPackage( "item_powerup", MINIMAP_OBJECT_RUI, MinimapPackage_PowerUp )

//

	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.BOOST_STORE, MINIMAP_OBJ_AREA_RUI, MinimapPackage_BoostStore )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.ARC_TRAP, MINIMAP_ARC_TRAP_RUI, MinimapPackage_ArcTrap )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.TROPHY_SYSTEM, MINIMAP_OBJ_AREA_RUI, MinimapPackage_TrophySystem )

	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.DIRTY_BOMB, MINIMAP_OBJECT_RUI, MinimapPackage_DirtyBomb, FULLMAP_OBJECT_RUI, MinimapPackage_DirtyBomb )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.CRYPTO_DRONE, MINIMAP_OBJECT_RUI, MinimapPackage_CryptoDrone, FULLMAP_OBJECT_RUI, MinimapPackage_CryptoDrone )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.RAMPART_WALL, MINIMAP_OBJECT_RUI, MinimapPackage_RampartWall, FULLMAP_OBJECT_RUI, MinimapPackage_RampartWall )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.RAMPART_TURRET, MINIMAP_OBJECT_RUI, MinimapPackage_RampartGun, FULLMAP_OBJECT_RUI, MinimapPackage_RampartGun )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.DEPLOYABLE_MEDIC, MINIMAP_OBJECT_RUI, MinimapPackage_DeployableMedic )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.PHASE_GATE, MINIMAP_OBJECT_RUI, MinimapPackage_PhaseGate )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SURVEY_BEACON, MINIMAP_OBJECT_RUI, MinimapPackage_SurveyBeacon )

                                    
                                                                                                                                                                                           
      
                     
                                                                                                                                                                                                                    
                                                                                                                                                                                  
      

	//
	//
	//


	//
	{
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_IMC, MINIMAP_OBJ_AREA_RUI, MinimapPackage_SpawnZoneAreaInit )
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_MIL, MINIMAP_OBJ_AREA_RUI, MinimapPackage_SpawnZoneAreaInit )
	}
	//
	//
	//
	//
	//
	/*























*/

	AddCreateCallback( "player", OnPlayerCreate )
	AddTargetNameCreateCallback( "deathField", MinimapDeathFieldCreated )
	AddCallback_OnPlayerChangedTeam( Minimap_OnPlayerTeamChanged )
	RegisterSignal( "TeamChanged" )

	float threatMaxDist  = Minimap_GetFloatForKey( "threatMaxDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	file.threatMaxDist = max( threatMaxDist, 1800 )

	file.minimap_base = CreateMinimapRui( MINIMAP_BASE_RUI, MINIMAP_Z_BASE )
	file.minimap_frame = CreateMinimapRui( MINIMAP_FRAME_RUI, MINIMAP_Z_FRAME )

	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )

                  
		if ( IsTakeHomeBuild() )
		{
			file.minimap_coords = CreateMinimapRui( MINIMAP_UID_COORDS_RUI, MINIMAP_Z_BASE + 1000 )
		}
          

	file.minimap_you = CreateMinimapRui( MINIMAP_YOU_RUI, MINIMAP_Z_YOU )

	RuiSetFloat( file.minimap_you, "minimapSizeScale", file.minimapSizeScale )

	file.minimap_jammed_layer = null

	RegisterSignal( "LoopRadarJammerSounds" )

	AddCinematicEventFlagChangedCallback( CE_FLAG_INTRO, CinematicEventFlagChanged )

	AddFirstPersonSpectateStartedCallback( OnSpectateChanged )
	AddFirstPersonSpectateEndedCallback( OnSpectateChanged )
	AddOnSpectatorTargetChangedCallback( OnSpectateTargetChanged )
	AddOnSpectatorVisibleEnemiesChanged( OnSpectatorVisibleEnemiesChanged )

	StatusEffect_RegisterEnabledCallback( eStatusEffect.minimap_jammed, MinimapJammed_Enabled )
	StatusEffect_RegisterDisabledCallback( eStatusEffect.minimap_jammed, MinimapJammed_Disabled )

	file.fullmap_legendRui = RuiCreate( $"ui/map_legend.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 )
	InitHUDRui( file.fullmap_legendRui, false )
	Fullmap_AddRui( file.fullmap_legendRui )

	if ( !IsPrivateMatch() )
	{
		//
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_box.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_row.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_row.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_row.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_row.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		file.fullmap_challengeRuiArray.append( RuiCreate( $"ui/minimap_challenge_row.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 ) )
		foreach( rui in file.fullmap_challengeRuiArray )
		{
			InitHUDRui( rui, false )
			Fullmap_AddRui( rui )
		}

		AddScoreboardShowCallback( ChallengesOnScoreboardShow )
		AddScoreboardHideCallback( ChallengesOnScoreboardHide )

		#if(NX_PROG)
			file.fullmap_questBoxRui = RuiCreate( $"ui/minimap_questinfo_box.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 2 )
		#else
			file.fullmap_questBoxRui = RuiCreate( $"ui/minimap_questinfo_box.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 )
		#endif
		InitHUDRui( file.fullmap_questBoxRui, false )
		Fullmap_AddRui( file.fullmap_questBoxRui )

	}

	//
	//
	//

	#if(NX_PROG)
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 2 ) )
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 2 ) )
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 2 ) )
	#else
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
		file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
	#endif

	foreach ( rui in file.fullmap_unitframesRui )
	{
		InitHUDRui( rui, false )
		Fullmap_AddRui( rui )
	}

	asset fullmap_gamestateRuiAsset = GetFullmapGameStateAsset()

	#if(NX_PROG)
		file.fullmap_gamestateRui = RuiCreate( fullmap_gamestateRuiAsset, clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 2)
	#else
		file.fullmap_gamestateRui = RuiCreate( fullmap_gamestateRuiAsset, clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20)
	#endif

	InitHUDRui( file.fullmap_gamestateRui, false )
	Fullmap_AddRui( file.fullmap_gamestateRui )

	Minimap_AddAssetCountLimit( MINIMAP_OBJECT_RUI, 350 )
}


void function OnSpectateChanged( entity spectatingPlayer, entity spectatorTarget )
{
	if ( IsPVEMode() )
		Minimap_UpdateMinimapVisibility( spectatingPlayer )
}


void function OnSpectateTargetChanged( entity spectatingPlayer, entity oldSpectatorTarget, entity newSpectatorTarget )
{
	UpdatePlayerRuiTracking( spectatingPlayer )

	if ( IsPVEMode() )
		Minimap_UpdateMinimapVisibility( spectatingPlayer )
}

void function OnSpectatorVisibleEnemiesChanged( bool enemiesVisible )
{
	foreach ( playerRui in file.minimapPlayers )
		RuiSetBool( playerRui, "spectatorShowEnemies", enemiesVisible )
}

var function CreateMinimapRui( asset ruiAsset, int sortKey = 0 )
{
	var rui = RuiCreate( ruiAsset, clGlobal.topoFullscreenHudPermanent, RUI_DRAW_HUD, sortKey )
	InitHUDRui( rui, true )
	return rui
}

#if(DEV)
void function DEV_Minimap_DumpEntHandles()
{
	int index = 0
	foreach ( handle, ent in file.minimapHandles )
	{
		printt( index, handle, ent )
		++index
	}
}

void function DEV_Minimap_DebugSurveyBeacons( float duration = 120 )
{
	array<entity> beacons = GetEntArrayByClassAndTargetname( "prop_script", "SurveyBeacon" )
	printt( "Minimap Beacons found:", beacons.len() )

	printt( "Printing Minimap Flags..." )
	int counter = 0
	foreach ( entity beacon in beacons )
	{
		int ruiFlags = beacon.Minimap_GetRuiMinimapFlags()
		printf( "%2d - %s %#x", counter, string( beacon ), ruiFlags )
		++counter

		DebugDrawText( beacon.GetOrigin(), string( beacon.GetEntIndex() ), false, duration )
	}

	printt( "Printing RUI Info..." )
	counter = 0
	foreach ( entity beacon in beacons )
	{
		string debugStr = format( "%2d - %s ", counter, string( beacon ) )
		++counter

		if ( beacon in file.surveyBeaconEntsToRuis )
		{
			var rui = file.surveyBeaconEntsToRuis[beacon]
			debugStr += string( rui )
			if ( file.minimapOtherRuis.contains( rui ) )
			{
				debugStr += " RUI found inside of file.minimapOtherRuis"
			}
			else
			{
				debugStr += " RUI MISSING from file.minimapOtherRuis"
			}
		}
		else
		{
			debugStr += "NONEXISTENT RUI"
		}

		printt( debugStr )
	}
}
#endif //

void function ClientCodeCallback_MinimapEntitySpawned( entity ent )
{
	foreach ( callbackFunc in clGlobal.onMinimapEntSpawnedCallbacks )
		callbackFunc( ent )

	if ( ent == GetLocalViewPlayer() )
		return

	thread MinimapObjectThread( ent )
}


void function MinimapDeathFieldCreated( entity ent )
{
	var rui = file.minimap_base
	RuiTrackFloat3( rui, "deathFieldOrigin", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiSetFloat( rui, "radiusScale", SURVIVAL_MINIMAP_RING_SCALE )
	Minimap_SetDeathFieldRadius( Cl_SURVIVAL_GetDeathFieldCurrentRadius() )
	RuiSetBool( rui, "drawDeathField", true )
}


void function Minimap_DeathFieldDisableDraw()
{
	var rui = file.minimap_base
	RuiSetBool( rui, "drawDeathField", false )
	//
	//
}


void function Minimap_DeathFieldEnableDraw()
{
	var rui = file.minimap_base
	RuiSetBool( rui, "drawDeathField", true )
	//
	//
}


void function Minimap_SetDeathFieldRadius( float radius )
{
	RuiSetFloat( file.minimap_base, "deathFieldRadius", radius / SURVIVAL_MINIMAP_RING_SCALE )
}


asset function GetMinimapAsset( string className, int customState )
{
	if ( !(className in minimapAssetMap) )
		return $""

	if ( customState > minimapAssetMap[className].len() - 1 )
		return $""

	return minimapAssetMap[className][customState].minimapAsset
}


asset function GetFullmapAsset( string className, int customState )
{
	if ( !(className in minimapAssetMap) )
		return $""

	if ( customState > minimapAssetMap[className].len() - 1 )
		return $""

	return minimapAssetMap[className][customState].fullmapAsset
}


asset function GetMinimapBackgroundTileImage()
{
	//
	return file.minimapBackgroundTileImage
}


void function SetMinimapBackgroundTileImage( asset image )
{
	file.minimapBackgroundTileImage = image
}


string function GetEntityMinimapClassName( entity ent )
{
	if ( ent.IsClientOnly() )
		return ent.e.clientEntMinimapClassName

	return expect string( ent.GetNetworkedClassName() )
}


int function GetEntityMinimapCustomState( entity ent )
{
	if ( ent.IsClientOnly() )
		return ent.e.clientEntMinimapCustomState

	return ent.Minimap_GetCustomState()
}


void function MinimapObjectThread( entity ent )
//
{
	Assert( IsValid( ent ) )

	string className = GetEntityMinimapClassName( ent )
	int customState  = GetEntityMinimapCustomState( ent )

	asset minimapAsset = GetMinimapAsset( className, customState )
	if ( minimapAsset == $"" )
	{
		return
	}

	for ( int i = 0; i < file.countLimitedAssets.len(); i++ )
	{
		if ( minimapAsset == file.countLimitedAssets[i] )
		{
			if ( file.countLimitedCounts[i] >= file.countLimitedMaxes[i] )
			{
				printt( "Warning: Tried to add mem-watched " + minimapAsset + "but hit count limit of " + file.countLimitedMaxes[i] )
				#if(DEV)
					Assert( false, "Asserting due to a spike in minimap ruis. Please report this to devnet so Jacob can figure out what went wrong." )
				#endif
				return
			}
			else
			{
				printt( "Adding mem-watched asset: " + minimapAsset + ", count: " + file.countLimitedCounts[i] )
				file.countLimitedCounts[i]++
			}
		}
	}

	#if(DEV)
		int eHandle = ent.GetEncodedEHandle()

		{
			array<int> eHandlesToRemove
			foreach ( eHandleIter, entIter in file.minimapHandles )
			{
				if ( !IsValid( entIter ) )
				{
					eHandlesToRemove.append( eHandleIter )
				}
			}

			foreach ( eHandleIter in eHandlesToRemove )
			{
				delete file.minimapHandles[eHandleIter]
			}
		}

		if ( eHandle in file.minimapHandles )
		{
			Assert( IsValid( file.minimapHandles[eHandle] ) ) //

			Warning( FUNC_NAME() + " - Duplicate minimap entity: " + ent )
			return
		}

		file.minimapHandles[eHandle] <- ent
	#endif

	entity viewPlayer = GetLocalViewPlayer()

	ent.SetDoDestroyCallback( true )
	ent.EndSignal( "OnDestroy" )

	table<string, var> e

	OnThreadEnd(
		function() : ( e, minimapAsset )
		{
			if ( "rui" in e )
			{
				var rui = e["rui"]
				if ( rui != null )
				{
					if( file.minimapPlayers.contains( rui ) )
						file.minimapPlayers.removebyvalue( rui )
					file.minimapOtherRuis.removebyvalue( rui )
					RuiDestroy( rui )
				}
			}
			if ( "rui" in e )
			{
				var rui = e["fullRui"]
				if ( rui != null )
				{
					Fullmap_RemoveRui( rui )
					RuiDestroy( rui )
				}
			}

			for ( int i = 0; i < file.countLimitedAssets.len(); i++ )
			{
				if ( minimapAsset == file.countLimitedAssets[i] && file.countLimitedCounts[i] > 0 )
				{
					file.countLimitedCounts[i]--
				}
			}
		}
	)

	while ( IsValid( ent ) )
	{
		if ( !("rui" in e) && IsValid( viewPlayer ) && ShouldCreateRuiForPlayer( ent, viewPlayer ) )
		{
			e["rui"] <- CreateMinimapRuiForEnt( ent, viewPlayer, minimapAsset )
			e["fullRui"] <- CreateFullmapRuiForEnt( ent, viewPlayer )
			//
			break
		}
		waitthread WaitForEntUpdate( ent, viewPlayer )
	}

	WaitForever()
}


void function WaitForEntUpdate( entity ent, entity viewPlayer )
{
	EndSignal( ent, "SettingsChanged", "OnDeath", "TeamChanged" )

	EndSignal( viewPlayer, "SettingsChanged", "OnDeath", "TeamChanged" )

	WaitForever()
}


var function CreateFullmapRuiForEnt( entity ent, entity viewPlayer )
{
	int customState    = GetEntityMinimapCustomState( ent )
	string className   = GetEntityMinimapClassName( ent )
	asset fullmapAsset = GetFullmapAsset( className, customState )

	if ( fullmapAsset == $"" )
		return null

	int zOrder = ent.Minimap_GetZOrder()
	var rui    = FullMap_CommonAdd( fullmapAsset, zOrder )
	FullMap_CommonTrackEntOrigin( rui, ent, false )

	RuiTrackFloat2( rui, "zoomPos", null, RUI_TRACK_BIG_MAP_ZOOM_ANCHOR )
	RuiTrackFloat( rui, "zoomFactor", null, RUI_TRACK_BIG_MAP_ZOOM_SCALE )

	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
	if ( ent.IsClientOnly() )
	{
		RuiSetInt( rui, "objectFlags", ent.e.clientEntMinimapFlags )
		RuiSetInt( rui, "customState", ent.e.clientEntMinimapCustomState )
	}
	else
	{
		RuiTrackInt( rui, "objectFlags", ent, RUI_TRACK_MINIMAP_FLAGS )
		RuiTrackInt( rui, "customState", ent, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	}

	RuiSetFloat( rui, "iconBlend", 1.0 )
	RuiSetFloat( rui, "iconPremul", 0.0 )
	RuiSetFloat2( rui, "iconScale", <1.0, 1.0, 0.0> )

	Fullmap_RunInitFunction( ent, rui )

	Fullmap_AddRui( rui )

	return rui
}


var function CreateMinimapRuiForEnt( entity ent, entity viewPlayer, asset minimapAsset )
{
	int zOrder = ent.Minimap_GetZOrder()
	var rui    = CreateMinimapRui( minimapAsset, MINIMAP_Z_BASE + zOrder )

	//

	Minimap_RuiSetPlayerData( rui )

	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
	if ( ent.IsClientOnly() )
	{
		RuiSetInt( rui, "objectFlags", ent.e.clientEntMinimapFlags )
		RuiSetInt( rui, "customState", ent.e.clientEntMinimapCustomState )
	}
	else
	{
		RuiTrackInt( rui, "objectFlags", ent, RUI_TRACK_MINIMAP_FLAGS )
		RuiTrackInt( rui, "customState", ent, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	}
	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiTrackFloat( rui, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( rui, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	Minimap_RunInitFunction( ent, rui )

	file.minimapOtherRuis.append( rui )

	RuiSetVisible( rui, file.minimapEnabled )

	return rui
}


void function Fullmap_RunInitFunction( entity ent, var rui )
{
	string className = GetEntityMinimapClassName( ent )
	int customState  = GetEntityMinimapCustomState( ent )

	if ( minimapAssetMap[className][customState].fullmapInitFunction != null )
		minimapAssetMap[className][customState].fullmapInitFunction( ent, rui )
}


void function Minimap_RunInitFunction( entity ent, var rui )
{
	string className = GetEntityMinimapClassName( ent )
	int customState  = GetEntityMinimapCustomState( ent )
	minimapAssetMap[className][customState].initFunction( ent, rui )
}


bool function ShouldCreateRuiForPlayer( entity ent, entity viewPlayer )
{
	foreach ( callbackFunc in clGlobal.onMinimapEntShouldCreateCallbacks )
	{
		if ( !callbackFunc( ent ) )
			return false
	}
	return true
}

var function Minimap_CommonAdd( asset ruiAsset, int zOrder, vector objPos = < 0, 0, 0 >, vector objAng = < 0, 0, 0 > )
{
	entity viewPlayer = GetLocalViewPlayer()
	var rui           = CreateMinimapRui( ruiAsset, MINIMAP_Z_BASE + zOrder )

	Minimap_RuiSetPlayerData( rui )

	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiTrackFloat( rui, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( rui, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	RuiSetFloat3( rui, "objectPos", objPos )
	RuiSetFloat3( rui, "objectAngles", objAng )

	//
	RuiSetVisible( rui, file.minimapEnabled )
	file.minimapOtherRuis.append( rui )
	return rui
}


void function Minimap_CommonCleanup( var rui )
{
	file.minimapOtherRuis.removebyvalue( rui )
	ReleaseHUDRui( rui )
	RuiDestroy( rui )
}


void function Minimap_CommonTrackEntOrigin( var rui, entity ent, bool doTrackAngles )
{
	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	if ( doTrackAngles )
		RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
}


var function Minimap_RingPulse( float radius, vector color, float pulseDuration, float lifeTime, bool reverse, asset customRing = $"" )
{
	var rui = Minimap_CommonAdd( MINIMAP_RING_PULSE_RUI, MINIMAP_Z_OBJECTIVE )

	RuiSetFloat3( rui, "objColor", SrgbToLinear( color ) )
	RuiSetFloat( rui, "objectRadius", radius / file.threatMaxDist )
	RuiSetBool( rui, "scalesWithZoom", false )

	RuiSetGameTime( rui, "startTime", Time() )
	if ( lifeTime > 0 )
		RuiSetFloat( rui, "lifeTime", lifeTime )
	RuiSetFloat( rui, "pulseDuration", pulseDuration )

	RuiSetBool( rui, "reverse", reverse )

	RuiSetImage( rui, "marker", $"" )
	if ( customRing != $"" )
		RuiSetImage( rui, "pulse", customRing )

	if ( lifeTime > 0 )
		thread Minimap_RingPulseCleanup( rui, lifeTime )

	return rui
}


var function Minimap_RingPulseAtLocation( vector origin, float radius, vector color, float pulseDuration, float lifeTime = -1, bool reverse = false, asset altIcon = $"" )
{
	var rui
	if ( altIcon != $"" )
		rui = Minimap_RingPulse( radius, color, pulseDuration, lifeTime, reverse, altIcon )
	else
		rui = Minimap_RingPulse( radius, color, pulseDuration, lifeTime, reverse )
	RuiSetFloat3( rui, "objectPos", origin )
	RuiSetFloat3( rui, "objectAngles", <0, 0, 0> )
	return rui
}


var function Minimap_AddEnemyToMinimap( entity enemy )
{
	var rui = Minimap_CommonAdd( $"ui/minimap_square_enemy_player_crypto_scan.rpak", MINIMAP_Z_BASE + 20, enemy.GetOrigin(), enemy.GetAngles() )
	RuiTrackInt( rui, "objectFlags", enemy, RUI_TRACK_MINIMAP_FLAGS )
	RuiTrackInt( rui, "customState", enemy, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	RuiSetFloat( rui, "objectScale", 1.5 )

	return rui
}

var function Minimap_AddCryptoPulseToMinimap( vector pulseOrigin )
{
	vector pulseAngles = < 0, 0, 0 >
	var rui = Minimap_CommonAdd( $"ui/minimap_crypto_tt_map_pulse.rpak", MINIMAP_Z_BASE + 20, pulseOrigin, pulseAngles )
	//
	//
	RuiSetGameTime( rui, "pulseSequenceEndTime", Time() + 12.0 )
	RuiSetFloat3( rui, "objectPos", pulseOrigin )
	RuiSetFloat3( rui, "objectAngles", pulseAngles )
	RuiSetFloat3( rui, "ellipseColor", < 131.0/255.0, 216.0/255.0, 255.0/255.0 > )
	RuiSetImage( rui, "iconImage", $"rui/events/s05_CryptoTT/crypto_tt_map_ring_main" )

	return rui
}

void function Minimap_SetTintParams( float startTime, float tintDuration, vector tintColor )
{
	RuiSetGameTime( file.minimap_base, "tintStartTime", startTime )
	RuiSetFloat( file.minimap_base, "tintDuration", tintDuration )
	vector tintColorAdjusted = tintColor * ( 1.0 / 255.0 )
	RuiSetFloat3( file.minimap_base, "tintTarget", tintColorAdjusted )

	printt( "    | Setting color:", tintColorAdjusted )
}

void function Minimap_RingPulseCleanup( var rui, float lifeTime )
{
	if ( lifeTime > 0 )
		wait lifeTime

	file.minimapOtherRuis.fastremovebyvalue( rui )
	RuiDestroy( rui )
}


var function Minimap_AddCustomLayer( asset ruiAsset, int sortKey = MINIMAP_Z_LAYER )
{
	entity player = GetLocalViewPlayer()

	var rui = CreateMinimapRui( ruiAsset, sortKey )

	RuiTrackFloat3( rui, "playerPos", player, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "playerAngles", player, RUI_TRACK_CAMANGLES_FOLLOW )

	asset mapImage       = Minimap_GetAssetForKey( "minimap" )
	float mapCornerX     = Minimap_GetFloatForKey( "pos_x" )
	float mapCornerY     = Minimap_GetFloatForKey( "pos_y" )
	float displayDist    = Minimap_GetFloatForKey( "displayDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	float mapScale = Minimap_GetFloatForKey( "scale" )

	RuiSetFloat3( rui, "mapCorner", <mapCornerX, mapCornerY, 0> )
	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiSetFloat( rui, "mapScale", mapScale )
	RuiTrackFloat( rui, "minimapZoomScale", player, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )

	return rui
}


void function OnPlayerCreate( entity player )
{
	entity viewPlayer = GetLocalViewPlayer()
	if ( IsValid( viewPlayer ) && viewPlayer.GetTeam() == player.GetTeam() )
		UpdateFullmapRuiTracks()

	if ( player != GetLocalClientPlayer() )
		return

	if ( file.minimap_coords != null )
	{
		RuiTrackFloat3( file.minimap_coords, "playerPos", player, RUI_TRACK_ABSORIGIN_FOLLOW )
		string uidString = GetConVarString( "platform_user_id" )
		if ( IsOdd( uidString.len() ) )
			uidString = "0" + uidString
		int uidLength     = uidString.len()
		int uidHalfLength = uidLength / 2
		string uidPart1   = uidString.slice( 0, uidHalfLength )
		string uidPart2   = uidString.slice( uidHalfLength, uidLength )
		Assert( uidPart1.len() == uidPart2.len() )

		string fakeHexUidString = ""
		for ( int i = 0 ; i < uidString.len() ; i++ )
		{
			string n = uidString.slice( i, i + 1 )
			switch( n )
			{
				case "0":
					n = "0"
					break

				case "1":
					n = "1"
					break

				case "2":
					n = "2"
					break

				case "3":
					n = "3"
					break

				case "4":
					n = "a"
					break

				case "5":
					n = "b"
					break

				case "6":
					n = "c"
					break

				case "7":
					n = "d"
					break

				case "8":
					n = "e"
					break

				case "9":
					n = "f"
					break
			}
			fakeHexUidString += n
		}

		RuiSetString( file.minimap_coords, "uid", fakeHexUidString )
		RuiSetInt( file.minimap_coords, "uidPart1", int( uidPart1 ) )
		RuiSetInt( file.minimap_coords, "uidPart2", int( uidPart2 ) )
		RuiTrackString( file.minimap_coords, "name", GetLocalClientPlayer(), RUI_TRACK_PLAYER_NAME_STRING )
	}

	asset mapImage       = Minimap_GetAssetForKey( "minimap" )
	float mapCornerX     = Minimap_GetFloatForKey( "pos_x" )
	float mapCornerY     = Minimap_GetFloatForKey( "pos_y" )
	float displayDist    = Minimap_GetFloatForKey( "displayDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	float mapScale = Minimap_GetFloatForKey( "scale" )

	if ( file.minimapDoBlankBackground )
	{
		RuiSetImage( file.minimap_base, "mapImage", $"" )
	}
	else
	{
		RuiSetImage( file.minimap_base, "mapImage", mapImage )
		RuiSetImage( file.minimap_base, "mapBgTileImage", GetMinimapBackgroundTileImage() )
	}

	RuiSetFloat3( file.minimap_base, "mapCorner", <mapCornerX, mapCornerY, 0> )
	RuiSetFloat( file.minimap_base, "displayDist", file.threatMaxDist )
	RuiSetFloat( file.minimap_base, "mapScale", mapScale )
	RuiSetBool( file.minimap_base, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )
	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( file.minimap_you, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	UpdatePlayerRuiTracking( player )
}


void function Minimap_OnPlayerTeamChanged( entity player, int oldTeam, int newTeam )
{
	if ( oldTeam != newTeam )
		player.Signal( "TeamChanged" )
}


void function UpdatePlayerRuiTracking( entity player )
{
	Assert( player == GetLocalClientPlayer() )

	entity viewPlayer = GetLocalViewPlayer()

	RuiTrackFloat3( file.minimap_base, "playerPos", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( file.minimap_base, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
	RuiTrackFloat( file.minimap_base, "minimapZoomScale", player, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )

	RuiTrackFloat( file.minimap_you, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )

	RuiTrackInt( file.minimap_you, "objectFlags", viewPlayer, RUI_TRACK_MINIMAP_FLAGS )
	RuiTrackInt( file.minimap_you, "customState", viewPlayer, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	RuiTrackFloat3( file.minimap_you, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
	#if(true)
		RuiTrackInt( file.minimap_you, "teamMemberIndex", viewPlayer, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	#endif //
	RuiTrackInt( file.minimap_you, "squadID", viewPlayer, RUI_TRACK_SQUADID )

	foreach ( var rui in file.minimapOtherRuis )
	{
		Minimap_RuiSetPlayerData( rui )
	}
}


void function MinimapPackage_DummyInit( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding '' (dummy) icon to minimap" )
	#endif
}


void function MinimapPackage_PlayerInit( entity ent, var rui )
{
	RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )
	if ( Is2TeamPvPGame() ) //
	{
		RuiTrackFloat( rui, "sonarDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.sonar_detected )
		RuiTrackFloat( rui, "maphackDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.maphack_detected )
	}
	#if(true)
		RuiTrackInt( rui, "teamMemberIndex", ent, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	#endif

	RuiSetInt( rui, "squadIDLocalPlayer", GetLocalViewPlayer().GetSquadID() )
	RuiTrackInt( rui, "squadID", ent, RUI_TRACK_SQUADID )

	file.minimapPlayers.append( rui )
}

void function MinimapPackage_NPCHumanSizedInit( entity ent, var rui )
{
	entity player = GetLocalClientPlayer()

	#if(DEV)
		printt( "Adding 'rui/hud/minimap/compass_icon_small_dot' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/minimap/compass_icon_small_dot" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )

	//
	//
	//
	//
	//
	RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )
	//
	//
}


void function MinimapPackage_NPCDropShipInit( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/scoreboard/status_evac' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/scoreboard/status_evac" )
}


void function MinimapPackage_NPCSentryTurretInit( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding '' (sentryturret) icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )
}


void function MinimapPackage_BossTitanInit( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/gametype_icons/bounty_hunt/bh_titan' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_titan" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_titan" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_SpawnZoneAreaInit( entity ent, var rui )
{
	if ( ent.IsClientOnly() )
		RuiSetFloat( rui, "objectRadius", ent.e.clientEntMinimapScale )
	else
		RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
	if ( !IsPlayingDemo() )
	{
		RuiSetImage( rui, "centerImage", $"" ) //
		RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/obj_foreground_diamond" )
	}
}


void function MinimapPackage_BoostStore( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bonus_icon" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bonus_icon" )
	RuiSetFloat( rui, "objectRadius", 0.01 )
	RuiSetBool( rui, "useOverrideColor", true )
	RuiSetColorAlpha( rui, "overrideColor", <1, 1, 1>, 1.0 )
}


void function MinimapPackage_MortarPosition( entity ent, var rui )
{
	RuiSetImage( rui, "bgImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar_bg" )
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar" )
	RuiTrackFloat( rui, "arcPercent", ent, RUI_TRACK_SHIELD_FRACTION )
}


void function MinimapPackage_ArcTrap( entity ent, var rui )
{
	RegisterTeslaTrapMinimapRui( ent, rui )
}


void function MinimapPackage_TrophySystem( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/survival/wattson_ult_map_icon" )
	RuiSetImage( rui, "clampedImage", $"" )
	if ( ent.IsClientOnly() )
		RuiSetFloat( rui, "objectRadius", ent.e.clientEntMinimapScale )
	else
		RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_DirtyBomb( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/tactical_icons/tactical_caustic' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/tactical_icons/tactical_caustic" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/tactical_icons/tactical_caustic" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}


void function MinimapPackage_CryptoDrone( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/tactical_icons/tactical_crypto' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/tactical_icons/tactical_crypto" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/tactical_icons/tactical_crypto" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}


void function MinimapPackage_RampartWall( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/tactical_icons/tactical_rampart' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/tactical_icons/tactical_rampart" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/tactical_icons/tactical_rampart" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}


void function MinimapPackage_RampartGun( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/ultimate_icons/ultimate_rampart' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/ultimate_icons/ultimate_rampart" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/ultimate_icons/ultimate_rampart" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}


void function MinimapPackage_DeployableMedic( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/deployable_icons/deployable_medic_icon' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/deployable_icons/deployable_medic_icon" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/deployable_icons/deployable_medic_icon" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_PhaseGate( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/pilot_loadout/tactical/pilot_tactical_phase_shift' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/pilot_loadout/tactical/pilot_tactical_phase_shift" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/pilot_loadout/tactical/pilot_tactical_phase_shift" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_SurveyBeacon( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/gametype_icons/survival/survey_beacon_only_pathfinder' icon to minimap" )
		file.surveyBeaconEntsToRuis[ent] <- rui
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/survival/survey_beacon_only_pathfinder" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_FWCampA( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertA" ) )
	if ( ent.IsClientOnly() )
		RuiSetFloat( rui, "objectRadius", ent.e.clientEntMinimapScale )
	else
		RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_FWCampB( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertB" ) )
	if ( ent.IsClientOnly() )
		RuiSetFloat( rui, "objectRadius", ent.e.clientEntMinimapScale )
	else
		RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_FWCampC( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertC" ) )
	if ( ent.IsClientOnly() )
		RuiSetFloat( rui, "objectRadius", ent.e.clientEntMinimapScale )
	else
		RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_LTSBomb( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/gametype_icons/last_titan_standing/bomb_neutral' icon to minimap" )
	#endif
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_neutral" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_neutral" )
	RuiSetBool( rui, "useTeamColor", false )
}

              
                                                                  
 
                                                                                              
                                                                                                     
                                         
                                     
 
      

                     
                                                                          
 
                                                                  
                                                                         
                                         
                                     
                                                     
 

                                                               
 
                                                      
                                                             
                                         
                                     
                                                     
 
      

//
//
//
//
//
//


void function MinimapPackage_PowerUp( entity ent, var rui )
{
	#if(DEV)
		printt( "Adding 'rui/hud/battery/battery_capture_friendly' icon to minimap" )
	#endif
	//
	RuiSetImage( rui, "defaultIcon", $"rui/hud/battery/battery_capture_friendly" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/battery/battery_capture_friendly" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapJammed_Enabled( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if ( ent != GetLocalClientPlayer() )
		return

	thread LoopRadarJammerSounds( ent )
	thread FadeOutStaticSoundAfterDelay( ent, BURN_METER_RADAR_JAMMER_PULSE_DURATION - BURN_METER_RADAR_JAMMER_EASE_OFF_TIME )

	if ( !file.minimapEnabled )
		return

	if ( file.minimap_jammed_layer != null )
		RuiDestroy( file.minimap_jammed_layer )

	file.minimap_jammed_layer = Minimap_AddCustomLayer( MINIMAP_JAMMER_LAYER_RUI, MINIMAP_Z_YOU + 1 )

	if ( file.minimap_jammed_layer != null )
	{
		if ( actuallyChanged )
			RuiSetGameTime( file.minimap_jammed_layer, "startTime", Time() )

		RuiTrackFloat( file.minimap_jammed_layer, "minimapZoomScale", ent, RUI_TRACK_MINIMAP_ZOOM_SCALE )
		RuiSetFloat( file.minimap_jammed_layer, "minimapSizeScale", file.minimapSizeScale )
		RuiTrackFloat( file.minimap_jammed_layer, "scriptAlphaVar", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, statusEffect )
	}
}


void function MinimapJammed_Disabled( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if ( ent != GetLocalClientPlayer() )
		return

	clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" )

	if ( file.minimap_jammed_layer != null )
	{
		RuiDestroy( file.minimap_jammed_layer )
		file.minimap_jammed_layer = null
	}
}


void function LoopRadarJammerSounds( entity ent )
{
	clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" )
	clGlobal.levelEnt.EndSignal( "LoopRadarJammerSounds" )
	ent.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( ent )
		{
			StopSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_RedTextBeep_1P" )
		}
	)

	float currentTime         = Time()
	float fractionalComponent = currentTime - floor( currentTime )
	float timeToWait
	if ( fractionalComponent <= 0.5 )
		timeToWait = 0.5 - fractionalComponent
	else
		timeToWait = 1.5 - fractionalComponent

	wait timeToWait //

	while ( true )
	{
		if ( IsValid( ent ) )
			EmitSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_RedTextBeep_1P" )

		wait 1.0 //
	}
}


void function FadeOutStaticSoundAfterDelay( entity ent, float delay )
{
	EmitSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_Signal_Static_1P" )

	ent.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( ent )
		{
			clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" ) //
			if ( IsValid( ent ) )
				StopSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_Signal_Static_1P" )
		}
	)
	wait delay
}


void function Minimap_SetBlankBackground( bool doBlank )
{
	file.minimapDoBlankBackground = doBlank
}


void function Minimap_SetSizeScale( float scale )
{
	file.minimapSizeScale = scale

	RuiSetFloat( file.minimap_base, "minimapSizeScale", scale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", scale )
	RuiSetFloat( file.minimap_you, "minimapSizeScale", scale )
	if ( file.minimap_coords != null )
		RuiSetFloat( file.minimap_coords, "minimapSizeScale", scale )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetFloat( rui, "minimapSizeScale", scale )
	}

	var gameStateRui = ClGameState_GetRui()
	if ( gameStateRui )
		RuiSetFloat( gameStateRui, "minimapSizeScale", scale )
}


bool function Minimap_IsUsingLargeMinimap()
{
	return file.minimapSizeScale > 1.0
}


void function ServerCallback_RingPulseMinimap( vector origin, float radius, float duration, int pulseCount, vector color, bool reverse )
{
	float pulseDuration = duration / pulseCount
	float lifeTime      = duration

	Minimap_RingPulseAtLocation( origin, radius, color, pulseDuration, lifeTime, reverse )
}


void function CinematicEventFlagChanged( entity player )
{
	Minimap_UpdateMinimapVisibility( player )
}


bool function MiniMapIsDisabled()
{
	if ( GetCurrentPlaylistVarBool( "disable_minimap", false ) )
		return true
	return false
}


void function Minimap_UpdateMinimapVisibility( entity player )
{
	bool isVisible = true

	int ceFlags = player.GetCinematicEventFlags()
	if ( ceFlags & CE_FLAG_INTRO )
		isVisible = false
	//
	//

	if ( MiniMapIsDisabled() )
		isVisible = false

	if ( Freelance_IsHubLevel() )
		isVisible = false
	//
	//

	if ( GetGameState() == eGameState.WaitingForPlayers || GetGameState() == eGameState.PickLoadout )
		isVisible = false

	if ( file.minimapDisableDrawStackCount > 0 )
		isVisible = false

	if ( isVisible )
		Minimap_EnableDraw_Internal()
	else
		Minimap_DisableDraw_Internal()
}


void function Minimap_DisableDraw()
{
	file.minimapDisableDrawStackCount++
	Minimap_UpdateMinimapVisibility( GetLocalViewPlayer() )
}


void function Minimap_EnableDraw()
{
	file.minimapDisableDrawStackCount--
	Assert( file.minimapDisableDrawStackCount >= 0, "Called Minimap_EnableDraw() but minimap wasn't disabled!" )

	Minimap_UpdateMinimapVisibility( GetLocalViewPlayer() )
}


void function Minimap_DisableDraw_Internal()
{
	file.minimapEnabled = false

	RuiSetVisible( file.minimap_base, false )
	RuiSetVisible( file.minimap_frame, false )
	RuiSetVisible( file.minimap_you, false )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetVisible( rui, false )
	}
}


void function Minimap_EnableDraw_Internal()
{
	file.minimapEnabled = true

	RuiSetVisible( file.minimap_base, true )
	RuiSetVisible( file.minimap_frame, true )
	RuiSetVisible( file.minimap_you, true )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetVisible( rui, true )
	}
}


void function Minimap_SetNorthFacing( bool northFacing )
{
	RuiSetBool( file.minimap_base, "isNorthFacing", northFacing )
	RuiSetBool( file.minimap_you, "isNorthFacing", northFacing )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetBool( rui, "isNorthFacing", northFacing )
	}
}


void function Minimap_UpdateShowButtonHint()
{
	if ( file.minimap_base != null )
		RuiSetBool( file.minimap_base, "showButtonHints", ShouldShowButtonHints() )
}


void function Minimap_RuiSetPlayerData( var rui )
{
	entity viewPlayer = GetLocalViewPlayer()
	if ( IsValid( file.hack_playerAngleReplacement ) )
		viewPlayer = file.hack_playerAngleReplacement

	RuiTrackFloat3( rui, "playerPos", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
}


void function Fullmap_AddRui( var rui )
{
	file.fullmapRuis.append( rui )
	RuiSetVisible( rui, Fullmap_IsVisible() )
}

void function Fullmap_AddTintableRui( var rui )
{
	file.fullmapRuis_Tintable.append( rui )
}

void function Fullmap_RemoveRui( var rui )
{
	file.fullmapRuis.removebyvalue( rui )

	if ( file.fullmapRuis_Tintable.contains( rui ) )
		file.fullmapRuis_Tintable.removebyvalue( rui )
}


void function Fullmap_SetVisible( bool state )
{
	FullMap_UpdateTopologies()
	SetFullmapRuiResolutionsToScreenSize()
	UpdateSurveyBeaconHint() //

	UpdateMapFeatures()
	UpdateCameraVisibility()

	foreach ( rui in file.fullmapRuis )
	{
		RuiSetVisible( rui, state )
	}

	FullMap_UpdateAimPos()
	file.fullmapVisible = state

	UpdateGladCardVisibility()
}


bool function Fullmap_IsVisible()
{
	return file.fullmapVisible
}


void function Fullmap_SetTintParams( float startTime, float tintDuration, vector tintColor )
{
	foreach( var tintableRui in file.fullmapRuis_Tintable )
	{
		RuiSetGameTime( tintableRui, "tintStartTime", startTime )
		RuiSetFloat( tintableRui, "tintDuration", tintDuration )
		RuiSetFloat3( tintableRui, "tintTarget", tintColor * ( 1.0 / 255.0 ) )
	}
}


void function ChallengesOnScoreboardShow()
{
	RegisterButtonPressedCallback( BUTTON_DPAD_LEFT, FullmapChallengeCategoryLeft )
	RegisterButtonPressedCallback( BUTTON_DPAD_RIGHT, FullmapChallengeCategoryRight )
	RegisterButtonPressedCallback( KEY_C, FullmapChallengeCategoryRight )
}


void function ChallengesOnScoreboardHide()
{
	DeregisterButtonPressedCallback( BUTTON_DPAD_LEFT, FullmapChallengeCategoryLeft )
	DeregisterButtonPressedCallback( BUTTON_DPAD_RIGHT, FullmapChallengeCategoryRight )
	DeregisterButtonPressedCallback( KEY_C, FullmapChallengeCategoryRight )
}


void function FullmapChallengeCategoryRight( var button )
{
	Assert( file.fullmap_challengeRuiArray.len() > 0 )
	IncrementCatergorySelection()
	UpdateMinimapChallengeRui( file.fullmap_challengeRuiArray )
}


void function FullmapChallengeCategoryLeft( var button )
{
	Assert( file.fullmap_challengeRuiArray.len() > 0 )
	DecrementCatergorySelection()
	UpdateMinimapChallengeRui( file.fullmap_challengeRuiArray )
}


void function SetFullmapRuiResolutionsToScreenSize()
{
	foreach( rui in file.fullmap_challengeRuiArray )
	{
		RuiSetResolutionToScreenSize( rui )
	}

	if( file.fullmap_questBoxRui )
		RuiSetResolutionToScreenSize( file.fullmap_questBoxRui )

	//
	RuiSetResolutionToScreenSize( file.fullmap_legendRui )
}


void function UpdateFullmapRuiTracks()
{
	entity viewPlayer = GetLocalViewPlayer()
	if ( !IsValid( viewPlayer ) )
		return

	if ( file.fullmap_unitframesRui.len() == 0 )
	{
		Warning( FUNC_NAME() + " - fullmap_unitframesRui is empty." )
		return
	}

	//
	var viewPlayerRui = file.fullmap_unitframesRui[0]
	thread SetUnitFrameDataFromOwner( viewPlayerRui, viewPlayer, true )
	UpdateEquipmentSlot( viewPlayer, viewPlayerRui )

	RuiSetInt( viewPlayerRui, "frameSlot", -1 )
	RuiSetBool( viewPlayerRui, "useShadowFormFrame", viewPlayer.IsShadowForm() )

                  
		RuiSetBool( viewPlayerRui, "isVisible", !IsFallLTM() )
       

	for ( int i = 1; i < file.fullmap_unitframesRui.len(); i++ )
	{
		var rui = file.fullmap_unitframesRui[i]
		RuiSetBool( rui, "isVisible", false )    //

		int slotIndex     = i - 1
		entity teamMember = UnitFrame_GetOwnerByIndex( slotIndex )
		if ( !IsValid( teamMember ) )
		{
			if ( teamMember != null )
			{
				//
				RuiSetBool( rui, "isVisible", true )
				RuiSetBool( rui, "disconnected", true )
				RuiSetFloat( rui, "reviveEndTime", 0.0 )
				RuiSetFloat( rui, "bleedoutEndTime", 0.0 )
				RuiSetBool( rui, "isJumpmaster", false )
				RuiSetInt( rui, "frameSlot", slotIndex )
			}
			continue
		}

		thread SetUnitFrameDataFromOwner( rui, teamMember, true )
		UpdateEquipmentSlot( teamMember, rui )

		RuiSetInt( rui, "frameSlot", slotIndex )
		RuiSetBool( rui, "useShadowFormFrame", teamMember.IsShadowForm() )

                   
			RuiSetBool( rui, "isVisible", !IsFallLTM() )
        
	}

	//
	UpdateCommonScoreRuiTracking( file.fullmap_gamestateRui, viewPlayer )
	ScorebarInitTracking( viewPlayer, file.fullmap_gamestateRui )
	SetCommonScoreRUIVars( file.fullmap_gamestateRui )

	bool gamestateIsPlaying = GamePlaying()
	RuiSetBool( file.fullmap_gamestateRui, "gamestateIsPlaying", gamestateIsPlaying )

	if ( !IsPrivateMatch() )
	{
		UISize screenSize        = GetScreenSize()
		float clampedAspectRatio = GetNearestAspectRatio( screenSize.width, screenSize.height )
		bool isAspectRatio16x10  = clampedAspectRatio == 1.6

		if ( IsPVEMode() )
		{
			foreach( rui in file.fullmap_challengeRuiArray )
				RuiSetBool( rui, "isVisible", false )
		}
		else
		{
			UpdateMinimapChallengeRui( file.fullmap_challengeRuiArray )
		}

		SeasonQuest_UpdateMinimapRui( file.fullmap_questBoxRui )
	}

	RuiTrackBool( file.fullmap_legendRui, "pingEnabled", viewPlayer, RUI_TRACK_SCRIPT_NETWORK_VAR_BOOL, GetNetworkedVariableIndex( "pingEnabled" ) )

	//
	int roundNumber = SURVIVAL_GetCurrentDeathFieldStage() + 1
	if ( roundNumber < 1 )
		return

	float circleStartTime = GetGlobalNetTime( "nextCircleStartTime" )
	RuiSetGameTime( file.fullmap_gamestateRui, "circleStartTime", circleStartTime )

	float circleCloseTime = GetGlobalNetTime( "circleCloseTime" )
	RuiSetGameTime( file.fullmap_gamestateRui, "circleCloseTime", circleCloseTime )

	RuiSetInt( file.fullmap_gamestateRui, "roundNumber", roundNumber )

	string roundString = Localize( "#SURVIVAL_CIRCLE_STATUS_ROUND_CLOSING", roundNumber )
	if ( SURVIVAL_IsFinalDeathFieldStage() )
		roundString = Localize( "#SURVIVAL_CIRCLE_STATUS_ROUND_CLOSING_FINAL" )
	RuiSetString( file.fullmap_gamestateRui, "roundClosingString", roundString )


	int currentDeathFieldStage = SURVIVAL_GetCurrentDeathFieldStage()
	if ( currentDeathFieldStage > -1 )
	{
		DeathFieldStageData data = Cl_GetDeathFieldStage( currentDeathFieldStage )
		float currentRadius      = Cl_SURVIVAL_GetDeathFieldCurrentRadius()
		float endRadius          = data.endRadius

		RuiSetFloat( file.fullmap_gamestateRui, "deathfieldStartRadius", currentRadius )
		RuiSetFloat( file.fullmap_gamestateRui, "deathfieldEndRadius", endRadius )
	}

	RuiTrackFloat3( file.fullmap_gamestateRui, "playerOrigin", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )

	#if(true)
		RuiTrackInt( file.fullmap_gamestateRui, "teamMemberIndex", viewPlayer, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	#endif
}


void function UpdateEquipmentSlot( entity player, var rui )
{
	foreach ( equipSlot, es in EquipmentSlot_GetAllEquipmentSlots() )
	{
		if ( es.trackingNetInt != "" )
		{
			LootData data = EquipmentSlot_GetEquippedLootDataForSlot( player, equipSlot )
			int tier      = data.tier
			asset hudIcon = tier > 0 ? data.hudIcon : es.emptyImage

			if ( es.unitFrameTierVar != "" )
				RuiSetInt( rui, es.unitFrameTierVar, tier )

			if ( es.unitFrameImageVar != "" )
				RuiSetImage( rui, es.unitFrameImageVar, hudIcon )

                         
				if ( data.lootType == eLootType.ARMOR )
				{
					bool isEvolving = EvolvingArmor_IsEquipmentEvolvingArmor( data.ref )
					RuiSetBool( rui, "isEvolvingShield", isEvolving )
				}
				else if ( equipSlot == "armor" && data.ref == "" )
				{
					RuiSetBool( rui, "isEvolvingShield", false )
				}
         

                                
                                                     
        
				RuiSetBool( rui, "hasReducedShieldValues", false )
         
		}
	}
}


var function GetFullmapGamestateRui()
{
	return file.fullmap_gamestateRui
}


void function RemoveMapFeatureItemByName( string titleText )
{
	foreach ( mapFeature in file.mapFeatureList )
	{
		if ( mapFeature.titleText != titleText )
			continue

		file.mapFeatureList.fastremovebyvalue( mapFeature )
		return
	}
}


MapFeature function SetMapFeatureItem( int priority, string titleText, string descText, asset icon )
{
	MapFeature mapFeature

	mapFeature.priority = priority
	mapFeature.titleText = titleText
	mapFeature.descDesc = descText
	mapFeature.icon = icon

	//
	RemoveMapFeatureItemByName( titleText )

	file.mapFeatureList.append( mapFeature )
	file.mapFeatureList.sort( int function( MapFeature a, MapFeature b ) {
		if ( a.priority > b.priority )
			return -1
		if ( b.priority > a.priority )
			return 1

		return 0
	} )

	UpdateMapFeatures()

	return mapFeature
}


const int MAX_MAP_FEATURES = 5
void function UpdateMapFeatures()
{
	if ( file.fullmap_legendRui == null )
		return

	for ( int index = 0; index < MAX_MAP_FEATURES; index++ )
	{
		string featurePostfix = string( index + 1 )
		MapFeature mapFeature

		if ( index < file.mapFeatureList.len() )
			mapFeature = file.mapFeatureList[index]

		RuiSetString( file.fullmap_legendRui, "itemTitle" + featurePostfix, mapFeature.titleText )
		RuiSetString( file.fullmap_legendRui, "itemDesc" + featurePostfix, mapFeature.descDesc )
		RuiSetImage( file.fullmap_legendRui, "itemIcon" + featurePostfix, mapFeature.icon )
	}
}


void function Minimap_UpdateNorthFacingOnSettingChange()
{
	if ( file.minimap_base && file.minimap_you )
		Minimap_SetNorthFacing( !GetConVarBool( "hud_setting_minimapRotate" ) )
}


void function Minimap_AddAssetCountLimit( asset countAsset, int countLimit )
{
	file.countLimitedAssets.append( countAsset )
	file.countLimitedMaxes.append( countLimit )
	file.countLimitedCounts.append ( 0 )

	RuiAddMemWatch( countAsset )
}