#if CLIENT || UI 
global function ShChallenges_LevelInit_PreStats
global function ShChallenges_LevelInit_PostStats
global function GetAllChallenges
global function Challenge_GetTierCount
global function Challenge_LastTierIsInfinite
global function Challenge_GetCurrentTier
global function Challenge_IsComplete
global function Challenge_GetTimeSpanKind
global function Challenge_GetGoalVal
global function Challenge_GetBPGrindPointsReward
global function Challenge_GetBPStarsReward
global function Challenge_GetBattlepassLevelsReward
global function Challenge_GetRewards
global function Challenge_IsPremium
global function Challenge_GetProgressValue
global function Challenge_GetSource
global function Challenge_GetStatRefs
global function Challenge_GetTimeSpan
global function Challenge_CanRerollChallenge
global function Challenge_IsChallengesStateInititated
global function DoesPlayerHaveChallenge
global function RegisterChallengeSource
global function RegisterChallengeFromAsset
global function Challenge_IsAssigned
global function Challenge_GetTierCompletionsAtProgress
global function Challenge_GetProgressToCompleteChallengeNumTimes

#if(DEV)
global function Challenge_GetTierDataBlock
global function Challenge_GetCharacterItemFlavors
global function PrintChallengePersistence
#endif
#endif //

#if CLIENT || UI 
global function Challenge_GetDescription
global function SetRuiArgsForChallengeTier
global function SetRuiArgsForChallengeReward
global function GetChallengeRewardDisplayData
global function UpdateChallengeCatergorySelection
global function IncrementCatergorySelection
global function DecrementCatergorySelection
global function SetSeasonColors
global function SetBattlePassLevelBadgeForLevel
#endif

#if(false)





#endif

#if(false)










//


#endif

#if(CLIENT)
global function ServerToClient_AssignedChallengesDidChange
global function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh
global function ServerToClient_ChallengeDataDidChange
global function UpdateMinimapChallengeRui
#endif

#if CLIENT && DEV 
global function PrintAllChallenges
#endif

#if(UI)
global function GetPlayerChallengeGroupData
global function GetPinnedChallenges
global function Challenge_IsPinned
global function ClientToUI_AssignedChallengesDidChange
global function ClientToUI_ChallengeDataDidChange
global function UpdateLobbyChallengeMenu
global function GetLobbyChallengeButtons
global function GetPlayerChallengesWithNewProgress
global function GetRowsInChallengeProgressDataArray
global function RefreshChallenges
global function MaybeAddChallengeClickEventToButton
global function RemoveChallengeFocusEventToButton
global function RemoveChallengeClickEventToButton
global function EventChallengesDidRefreshOnUI
global function UpdateChallengeRowsRui
global function TrySetBattlePassRewardOnButton
global function GetStarChallengeProgressStartLastMatch
global function UpdateChallengeBoxHeaderBPProgress
global function ChallengeInspectNextReward
#endif


//
//
//
//
//

#if CLIENT || UI 
enum eChallengeCategory
{
	DAILY,
	EVENT,
	TOP_WEEKLY
}

global enum eChallegeDifficulty
{
	VERY_EASY,
	EASY,
	MEDIUM,
	HARD,
	VERY_HARD
}

global enum eChallengeTimeSpanKind
{
	DAILY,
	SEASON_WEEKLY,
	SEASON_WEEKLY_RECURRING,
	EVENT,
	EVENT_SPECIAL,
}

global enum eChallengeRewardStyle
{
	//
	ITEM_GENERAL = 1
	ITEM_BADGE = 2
	ITEM_WEAPON_SKIN = 3
}
global enum eTinyLabelPlacementStyle
{
	//
	NONE = 0
	LEFT = 1
	CENTER = 2
}
#endif


#if(UI)
global struct ChallengeGroupData
{
	string               groupName
	array<ItemFlavor>    challenges
	int                  completedChallenges
	int                  timeSpanKind
}
#endif

#if(UI)
global struct ChallengeProgressData
{
	//
	ItemFlavor& challengeFlav
	int         challengeGUID
	int         tier
	int         startProgress
	int         endProgress
	int         goalProgress
	bool        isTierCompleted
	bool        isEventChallenge
	bool        isEventMain
	bool        isPinned

	array<ChallengeProgressData>        groupArray
}
#endif

#if CLIENT || UI 
global struct ChallengeRewardDisplayData
{
	ItemFlavor&       flav
	int               originalQuantity
	int               displayQuantity
	int               style
	int               rarityTier
	asset             icon
	ItemFlavor ornull badgeFlav
	int               badgeTier = -1
	string            tinyLabelText = ""
	int               tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE
}
#endif

#if CLIENT || UI 
struct ChallengeSortStruct
{
	//
	float progressFrac,
	int week,
	int difficulty,
	ItemFlavor& challengeFlav
}
#endif

const string CHALLENGE_REROLL_SOUND = "UI_Menu_Challenge_ReRoll"

//
//
//
//
//

const bool CHALLENGE_DEBUG = false

//
const int MAX_UNOWNED_CHAR_CHALLENGE = 1
const array<int> DAILY_CHALLENGE_SET = [ eChallegeDifficulty.VERY_EASY, eChallegeDifficulty.EASY, eChallegeDifficulty.MEDIUM, eChallegeDifficulty.HARD, eChallegeDifficulty.VERY_HARD ]
const int NUM_DAILY_CHALLENGES = 4 //
const int NUM_WEEKLY_CHALLENGES_MAX = 10
const int NUM_CHALLENGE_WEEKS_MAX = 13
const int NUM_CHALLENGE_BUFFER_FOR_EVENTS = 8
const int NUM_CHALLENGES_MAX = (NUM_WEEKLY_CHALLENGES_MAX * NUM_CHALLENGE_WEEKS_MAX) + NUM_DAILY_CHALLENGES + NUM_CHALLENGE_BUFFER_FOR_EVENTS
const int NUM_POST_GAME_CHALLENGES_MAX = 32
//

global const int MAX_REWARDS_PER_CHALLENGE_TIER = 4 //
//

const asset BATTLE_COMPLETED_HEADER_IMAGE = $"rui/menu/battlepass/battle_pass_completed_header"

#if CLIENT || UI 
struct ChallengeState
{
	int         persistenceIdx = -1
	ItemFlavor& flav
}
#endif


#if CLIENT || UI 
struct PlayerChallengesState
{
	table<ItemFlavor, ChallengeState>   challengeStateMap
	array<ChallengeState ornull>        persistentArrayMirror
}
#endif


#if CLIENT || UI 
struct FileStruct_LifetimeLevel
{
	//
	table<StatEntry, array<ItemFlavor> > statEntryChallengesMap
	table<ItemFlavor, ItemFlavor>        challengeSourceMap
	table<ItemFlavor, int>               challengeSortOrdinalMap

	#if(false)



#elseif CLIENT || UI 
		PlayerChallengesState localPlayerChallengesState
		int                   _challengeCategorySelectionIndex
		#if(UI)
			bool haveEventChallengesRefreshedOnUI = false
		#endif
	#endif
}
FileStruct_LifetimeLevel& fileLevel

const array<int> REROLL_COSTS = [ 2, 5, 10 ]
#endif

#if CLIENT || UI 
struct
{
	bool                    initialized = false
	BattlePassReward ornull nextBattlePassReward
} file
#endif

table<var, void functionref(var)> WORKAROUND_challengeButtonToFocusHandlerMap = {} //
table<var, void functionref(var)> WORKAROUND_challengeButtonToClickHandlerMap = {} //


//
//
//
//
//

#if CLIENT || UI 
void function ShChallenges_LevelInit_PreStats()
{
	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	AddCallback_OnItemFlavorRegistered( eItemType.challenge, OnChallengeRegistered )

	#if(false)

#endif

	#if(CLIENT)
		RegisterSignal( "ChallengeDataDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange_FromEventsRefresh" )
		Remote_RegisterClientFunction( "ServerToClient_ChallengeDataDidChange", "bool" )

		Remote_RegisterServerFunction( "ClientCallback_Challenge_ReRoll", "int", INT_MIN, INT_MAX )
	#endif

	#if(UI)
		if ( !file.initialized )
		{
			AddUICallback_OnResolutionChanged( RefreshChallenges )
		}

		foreach ( var button, void functionref(var) focusHandler in WORKAROUND_challengeButtonToFocusHandlerMap )
		{
			if ( IsValid( button ) )
				Hud_RemoveEventHandler( button, UIE_GET_FOCUS, focusHandler )
		}
		WORKAROUND_challengeButtonToFocusHandlerMap.clear()

		foreach ( var button, void functionref(var) clickHandler in WORKAROUND_challengeButtonToClickHandlerMap )
		{
			if ( IsValid( button ) )
				Hud_RemoveEventHandler( button, UIE_CLICK, clickHandler )
		}
		WORKAROUND_challengeButtonToClickHandlerMap.clear()
	#endif

	file.initialized = true
}

ItemFlavor ornull function RegisterChallengeFromAsset( asset challengeAsset )
{
	//
	var settingsBlock = GetSettingsBlockForAsset( challengeAsset )
	var tierDataArray = GetSettingsBlockArray( settingsBlock, "tiers" )
	for ( int i = 0 ; i < GetSettingsArraySize( tierDataArray ) ; i++ )
	{
		var tierBlock       = GetSettingsArrayElem( tierDataArray, i )
		var charactersArray = GetSettingsBlockArray( tierBlock, "characters" )
		foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
		{
			asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
			if ( !IsValidItemFlavorSettingsAsset( characterAsset ) )
			{
				Warning( "Skipping challenge %s because character %s is not registered", string(challengeAsset), string(characterAsset) )
				continue
			}
		}
	}

	//
	ItemFlavor ornull challenge = RegisterItemFlavorFromSettingsAsset( challengeAsset )

	return challenge
}
#endif


#if CLIENT || UI 
void function ShChallenges_LevelInit_PostStats()
{
	#if(DEV)
		if ( DEV_ShouldIgnorePersistence() )
			return
	#endif

	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
		int tierCount = Challenge_GetTierCount( challenge )
		for ( int i = 0 ; i < tierCount ; i++ )
		{
			array<string> statRefs = Challenge_GetStatRefs( challenge, i )
			foreach ( string statRef in statRefs )
			{
				if ( !IsValidStatEntryRef( statRef ) )
				{
					Assert( 0, format( "Challenge '%s' tier %d refers to non-existant stat: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), i, statRef ) )
					continue
				}

				StatEntry stat = GetStatEntryByRef( statRef )

				if ( (StatEntry_GetFlags( stat ) & eStatFlags.STORE_START_OF_PREVIOUS_MATCH) == 0 )
				{
					Assert( 0, format( "Challenge '%s' refers to stat that does not have the STORE_END_OF_PREVIOUS_MATCH flag: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
					continue
				}

				if ( (StatEntry_GetFlags( stat ) & eStatFlags.PERSISTENCE_WRITE_IMMEDIATELY) == 0 )
				{
					Assert( 0, format( "Challenge '%s' refers to stat that does not have the PERSISTENCE_WRITE_IMMEDIATELY flag: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
					continue
				}

				if ( !(stat in fileLevel.statEntryChallengesMap) )
					fileLevel.statEntryChallengesMap[ stat ] <- []
				fileLevel.statEntryChallengesMap[ stat ].append( challenge )
			}

			if ( Challenge_GetGoalVal( challenge, i ) <= 0 )
			{
				Assert( 0, format( "Challenge '%s' has invalid goal val: %d", ItemFlavor_GetHumanReadableRef( challenge ), Challenge_GetGoalVal( challenge, i ) ) )
				continue
			}
		}
	}

	#if(UI)
		thread InitChallengesThread()
	#endif
}
#endif

#if(UI)
void function InitChallengesThread()
{
	while ( !IsFullyConnected() )
		WaitFrame()

	ClientToUI_AssignedChallengesDidChange()
	ClientToUI_ChallengeDataDidChange( false ) //

	SetChallengeCategoryToEventIfAvailable()
}
#endif

#if CLIENT || UI 
void function RegisterChallengeSource( ItemFlavor challengeFlav, ItemFlavor sourceFlav, int sortOrdinal )
{
	if ( challengeFlav in fileLevel.challengeSourceMap )
	{
		Warning( "Challenge %s source is ambiguous: %s, %s", ItemFlavor_GetHumanReadableRef( challengeFlav ), ItemFlavor_GetHumanReadableRef( fileLevel.challengeSourceMap[challengeFlav] ), ItemFlavor_GetHumanReadableRef( sourceFlav ) )
		return
	}
	fileLevel.challengeSourceMap[challengeFlav] <- sourceFlav
	fileLevel.challengeSortOrdinalMap[challengeFlav] <- sortOrdinal
}
#endif


#if(false)








//




//










#endif


#if CLIENT || UI 
void function OnChallengeRegistered( ItemFlavor challenge )
{
	//
}
#endif


#if(false)

















//
























#endif


#if(CLIENT)
void function ServerToClient_AssignedChallengesDidChange()
{
	ServerToClient_AssignedChallengesDidChange_Common( false )
}
#endif


#if(CLIENT)
void function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh()
{
	ServerToClient_AssignedChallengesDidChange_Common( true )
}
#endif


#if(CLIENT)
void function ServerToClient_AssignedChallengesDidChange_Common( bool didEventChallengesRefresh )
{
	InitPlayerChallengesStateFromPersistence( GetLocalClientPlayer(), fileLevel.localPlayerChallengesState )
	RunUIScript( "ClientToUI_AssignedChallengesDidChange" )

	ServerToClient_ChallengeDataDidChange( didEventChallengesRefresh )
}
#endif


#if(UI)
void function ClientToUI_AssignedChallengesDidChange()
{
	InitPlayerChallengesStateFromPersistence( GetUIPlayer(), fileLevel.localPlayerChallengesState )
}
#endif


#if(CLIENT)
void function ServerToClient_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	RunUIScript( "ClientToUI_ChallengeDataDidChange", didEventChallengesRefresh )
}
#endif


#if(UI)
void function ClientToUI_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	if ( IsLobby() && IsLocalClientEHIValid() )
	{
		UpdateLobbyChallengeMenu()

		#if(NX_PROG)
			if ( !IsNxHandheldMode() )
				UpdateMiniPromoPinning()
		#else
			UpdateMiniPromoPinning()
		#endif
		var button = AllChallengesMenu_GetLastGroupButton()
		AllChallengesMenu_UpdateCategories( null )
		if ( button != null )
			AllChallengesMenu_SetLastGroupButton( button )
		AllChallengesMenu_ActivateLastGroupButton()

		if ( didEventChallengesRefresh )
			fileLevel.haveEventChallengesRefreshedOnUI = true
	}
}
#endif


#if(UI)
bool function EventChallengesDidRefreshOnUI()
{
	return fileLevel.haveEventChallengesRefreshedOnUI
}
#endif


#if(UI)
void function UpdateLobbyChallengeMenu()
{
	#if(false)

#endif

	if ( !IsConnected() )
		return

	//
	var playPanel                  = GetPanel( "PlayPanel" )
	var challengesBoxHeader        = Hud_GetChild( playPanel, "ChallengesBox" )
	var battlePassNextRewardButton = Hud_GetChild( playPanel, "ChallengesNextBPReward" )
	var challengesBoxHeaderRui     = Hud_GetRui( challengesBoxHeader ) //
	var allChallengesButton        = Hud_GetChild( playPanel, "AllChallengesButton" )

	var challengeCatergoryLeft      = Hud_GetChild( playPanel, "ChallengeCatergoryLeftButton" )
	var challengeCatergorySelection = Hud_GetChild( playPanel, "ChallengeCatergorySelection" )
	var challengeCatergoryRight     = Hud_GetChild( playPanel, "ChallengeCatergoryRightButton" )
	var eventPrizeTrackButton       = Hud_GetChild( playPanel, "EventPrizeTrackButton" )


	array<var> btnList = GetLobbyChallengeButtons()

	entity player = GetUIPlayer()

                        
                              
   
                                
                      

                                  
                                         
                                  
                                     
                                          
                                      
                                    
         
 
       

	int timestamp                  = GetUnixTimestamp()
	ItemFlavor ornull currentEvent = GetActiveBuffetEvent( timestamp )

	int challengeCategory        = GetChallengeDisplayCategory()
	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )

	UpdateChallengeCatergorySelection( Hud_GetRui( challengeCatergorySelection ) )
	UpdateChallengeCatergoryTint( currentEvent, challengeCatergoryLeft, challengeCatergorySelection, challengeCatergoryRight, allChallengesButton )

	UpdateChallengeBoxRowButtons( player, challenges, btnList )
	UpdateChallengeBoxHeader( player, challengesBoxHeader, currentEvent )
	UpdateChallengeBoxHeaderReward( player, battlePassNextRewardButton )
	UpdateEventTrackButton( player, eventPrizeTrackButton, currentEvent )

	Hud_Show( challengesBoxHeader )
	Hud_Show( allChallengesButton )
	Hud_Show( challengeCatergoryLeft )
	Hud_Show( challengeCatergorySelection )
	Hud_Show( challengeCatergoryRight )

	bool isAnyChallengeNew = false
	foreach ( ChallengeGroupData cgd in GetPlayerChallengeGroupData( GetUIPlayer() ) )
	{
		foreach ( ItemFlavor challenge in cgd.challenges )
		{
			if ( Newness_IsItemFlavorNew( challenge ) && cgd.timeSpanKind != eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING )
			{
				isAnyChallengeNew = true
				break
			}
		}
	}
	Hud_SetNew( allChallengesButton, isAnyChallengeNew )
}
#endif

#if(CLIENT)
void function UpdateMinimapChallengeRui( array<var> ruiArray )
{
	if ( !IsConnected() )
		return

	#if(false)

#endif

	//
	var titleRui           = ruiArray[0]
	array<var> rowRuiArray = clone ruiArray
	rowRuiArray.remove( 0 )

	entity player = GetLocalClientPlayer()

	int timestamp                  = GetUnixTimestamp()
	ItemFlavor ornull currentEvent = GetActiveBuffetEvent( timestamp )

	int challengeCategory        = GetChallengeDisplayCategory()
	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )

	UpdateChallengeCatergorySelection( titleRui, true )
	UpdateChallengeRowsRui( player, challenges, rowRuiArray )
}
#endif

#if UI || CLIENT 
array<ItemFlavor> function GetChallengesByCategory( entity player, int challengeCategory, ItemFlavor ornull currentEvent )
{
	bool hasActiveEvent = false
	if ( currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		hasActiveEvent = true
	}

	array<ItemFlavor> challenges
	switch( challengeCategory )
	{
		case eChallengeCategory.DAILY:
			challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.DAILY )
			break

		case eChallengeCategory.EVENT:
			challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT )
			break

		case eChallengeCategory.TOP_WEEKLY:
			challenges = GetWeeklyChallengesSortedByProgress( player )
			break

			unreachable
	}

	return challenges
}
#endif

#if CLIENT || UI 
array<ItemFlavor> function GetWeeklyChallengesSortedByProgress( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = 5

	array<ChallengeSortStruct> challengeSortArray

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpan( challengeFlav ) == eChallengeTimeSpanKind.SEASON_WEEKLY )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( Challenge_IsComplete( player, challengeFlav ) )
				continue

			int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
			int goalVal     = Challenge_GetGoalVal( challengeFlav, currentTier )

			int current            = 0
			array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier )
			foreach ( string statRef in statRefs )
			{
				Assert( IsValidStatEntryRef( statRef ) )
				StatEntry entry = GetStatEntryByRef( statRef )
				Assert( entry.type == eStatType.INT )
				current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
			}

			int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

			ChallengeSortStruct sortStruct
			sortStruct.progressFrac = float(current - marker) / float(goalVal)
			sortStruct.week = Challenge_FindAssignedWeekOrder( player, challengeFlav )
			sortStruct.difficulty = Challenge_GetDifficulty( challengeFlav )
			sortStruct.challengeFlav = challengeFlav

			challengeSortArray.append( sortStruct )
		}
	}
	challengeSortArray.sort( Challenge_SortByProgress )
	#if(DEV)
		foreach ( ChallengeSortStruct sortStruct in challengeSortArray )
		{
			printt( sortStruct.challengeFlav._____INTERNAL_humanReadableRef + "\t" + sortStruct.progressFrac + "\t" + sortStruct.week )
		}
	#endif

	array<ItemFlavor> topWeeklyChallenges = []
	int maxSize                           = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	string prevDescription
	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		ItemFlavor challenge = challengeSortArray[ index ].challengeFlav
		int challengeTier    = Challenge_GetCurrentTier( player, challenge )
		string challengeDesc = Challenge_GetDescription( challenge, challengeTier )
		if ( challengeDesc == prevDescription )
		{
			//
			continue
		}

		prevDescription = challengeDesc
		topWeeklyChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topWeeklyChallenges.len() >= maxSize )
			break
	}

	return topWeeklyChallenges
}
#endif

#if CLIENT || UI 
int function Challenge_FindAssignedWeekOrder( entity player, ItemFlavor challengeFlav )
{
	int weekIndex = Challenge_GetWeekNumber( challengeFlav )

	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{
		#if(CLIENT)
			int groupIndex = player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		#else
			int groupIndex = GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		#endif
		if ( groupIndex == weekIndex )
			return i
	}

	return -1    //
}
#endif

#if CLIENT || UI 
int function Challenge_SortByProgress( ChallengeSortStruct a, ChallengeSortStruct b )
{
	//
	if ( a.progressFrac < b.progressFrac )
		return 1
	else if ( a.progressFrac > b.progressFrac )
		return -1

	//
	if ( a.week > b.week )
		return 1
	else if ( a.week < b.week )
		return -1

	//
	if ( a.difficulty > b.difficulty )
		return 1
	else if ( a.difficulty < b.difficulty )
		return -1

	return 0
}
#endif

#if UI || CLIENT 
array<int> function GetChallengeCategoryIDArray()
{
	int timestamp                  = GetUnixTimestamp()
	ItemFlavor ornull currentEvent = GetActiveBuffetEvent( timestamp )

	array<int> categoryIDtoStringArray = [ eChallengeCategory.DAILY, eChallengeCategory.EVENT, eChallengeCategory.TOP_WEEKLY ]
	if ( currentEvent == null )
		categoryIDtoStringArray.removebyvalue( eChallengeCategory.EVENT )
	return categoryIDtoStringArray
}

void function UpdateChallengeCatergorySelection( var rui, bool longName = false )
{
	//
	if ( !IsConnected() )
		return

	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray()
	int selectionSlots                 = categoryIDtoStringArray.len()
	Assert( selectionSlots >= 1 || selectionSlots < 3, "Tried to add to many options to the selection rui. Max 3." )

	int newSelectionIndex = ClampInt( fileLevel._challengeCategorySelectionIndex, 0, selectionSlots )
	fileLevel._challengeCategorySelectionIndex = newSelectionIndex

	string category = GetCategoryStringFromType( categoryIDtoStringArray[ newSelectionIndex ], longName )
	RuiSetInt( rui, "selectionSlots", selectionSlots )    //
	RuiSetInt( rui, "selectionID", newSelectionIndex ) //
	RuiSetString( rui, "selectionText", category ) //

	#if(UI)
		switch( GetChallengeDisplayCategory() )
		{
			case eChallengeCategory.DAILY:
				int remainingDuration = GetPersistentVarAsInt( "dailyExpirationTime" ) - Daily_GetCurrentTime()
				RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? Time() + remainingDuration : RUI_BADGAMETIME )
				RuiSetBool( rui, "eventActive", false )
				break

			case eChallengeCategory.EVENT:
				int timestamp = GetUnixTimestamp()
				ItemFlavor ornull currentEvent = GetActiveBuffetEvent( timestamp )

				Assert( currentEvent != null )
				expect ItemFlavor( currentEvent )
				Assert( ItemFlavor_GetType( currentEvent ) == eItemType.calevent_buffet )

				int endTime = CalEvent_GetFinishUnixTime( currentEvent )
				int remainingDuration = endTime - GetUnixTimestamp()

				RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? Time() + remainingDuration : RUI_BADGAMETIME )
				RuiSetBool( rui, "eventActive", true )
				break

			case eChallengeCategory.TOP_WEEKLY:
				RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
				RuiSetBool( rui, "eventActive", false )
				break
		}
	#endif
}
#endif

#if(UI)
void function SetChallengeCategoryToEventIfAvailable()
{
	array<int> categoryIDArray = GetChallengeCategoryIDArray()

	foreach( int index, int categoryID in categoryIDArray )
	{
		if ( categoryID == eChallengeCategory.EVENT )
		{
			fileLevel._challengeCategorySelectionIndex = index
			break
		}
	}
}
#endif

#if(UI)
void function UpdateChallengeCatergoryTint( ItemFlavor ornull event, var challengeCatergoryLeft, var challengeCatergorySelection, var challengeCatergoryRight, var allChallengesButton )
{
	array<var> ruiArray
	ruiArray.append( Hud_GetRui( challengeCatergoryLeft ) )
	ruiArray.append( Hud_GetRui( challengeCatergorySelection ) )
	ruiArray.append( Hud_GetRui( challengeCatergoryRight ) )
	ruiArray.append( Hud_GetRui( allChallengesButton ) )

	vector tint = <1, 1, 1>
	if ( GetChallengeDisplayCategory() == eChallengeCategory.EVENT )
	{
		Assert( event != null )
		expect ItemFlavor( event )
		tint = BuffetEvent_GetCategoryButtonTint( event )
	}

	foreach ( var rui in ruiArray )
	{
		RuiSetFloat3( rui, "backgroundTint", tint )
	}
}
#endif

#if UI || CLIENT 
int function GetCategorySelectionSize()
{
	int timestamp                  = GetUnixTimestamp()
	ItemFlavor ornull currentEvent = GetActiveBuffetEvent( timestamp )
	if ( currentEvent == null )
		return 2
	return 3
}
#endif

#if UI || CLIENT 
void function IncrementCatergorySelection( var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (fileLevel._challengeCategorySelectionIndex + 1) % GetCategorySelectionSize()
	fileLevel._challengeCategorySelectionIndex = newSelection
}
#endif

#if UI || CLIENT 
void function DecrementCatergorySelection( var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (GetCategorySelectionSize() + fileLevel._challengeCategorySelectionIndex - 1) % GetCategorySelectionSize()
	fileLevel._challengeCategorySelectionIndex = newSelection
}
#endif

#if UI || CLIENT 
int function GetChallengeDisplayCategory()
{
	//
	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray()
	Assert( fileLevel._challengeCategorySelectionIndex < categoryIDtoStringArray.len() )

	return categoryIDtoStringArray[ fileLevel._challengeCategorySelectionIndex ]
}
#endif

#if UI || CLIENT 
string function GetCategoryStringFromType( int categoryID, bool longName = false )
{
	string appendStr = longName ? "_CHALLENGES" : ""

	switch( categoryID )
	{
		case eChallengeCategory.DAILY:
			return "#CATEGORY_DAILY" + appendStr
			break

		case eChallengeCategory.EVENT:
			return "#CATEGORY_EVENT" + appendStr
			break

		case eChallengeCategory.TOP_WEEKLY:
			return "#CATEGORY_TOP_WEEKLY" + appendStr
			break
	}

	unreachable
}
#endif

#if UI || CLIENT 
void function SetSeasonColors( var rui )
{
	ItemFlavor ornull season = GetActiveSeason( GetUnixTimestamp() )

	if ( season != null )
	{
		expect ItemFlavor( season )
		RuiSetFloat3( rui, "seasonBGColor", Season_GetTabBGDefaultCol( season ) )
		RuiSetFloat3( rui, "seasonColor", Season_GetTabBGSelectedCol( season ) )
	}
}
#endif

#if(UI)
array<var> function GetLobbyChallengeButtons()
{
	var playPanel = GetPanel( "PlayPanel" )

	array<var> buttons
	for ( int rowIdx = 0; rowIdx < 5; rowIdx++ )
		buttons.append( Hud_GetChild( playPanel, "ChallengeButton" + rowIdx ) )

	return buttons
}
#endif











































//
//
//
//
//

#if(UI)
array<ChallengeGroupData> function GetPlayerChallengeGroupData( entity player )
{
	Assert( player == GetUIPlayer() )
	array<ChallengeGroupData> groupData
	array<ItemFlavor> challenges = []

	challenges = GetAssignedChallengesByTimeSpan( GetUIPlayer(), eChallengeTimeSpanKind.DAILY )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_DAILY" ), challenges, eChallengeTimeSpanKind.DAILY ) )

	//
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_SEASON_WEEKLY_RECURRING" ), challenges, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING ) )

	//
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT" ), challenges, eChallengeTimeSpanKind.EVENT ) )

	//
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT_SPECIAL )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT_SPECIAL" ), challenges, eChallengeTimeSpanKind.EVENT_SPECIAL ) )

	//
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{
		int groupIndex = GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		if ( groupIndex == 0 )
			break //
		challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.SEASON_WEEKLY, groupIndex )
		if ( challenges.len() > 0 )
			groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_WEEKLY", i + 1 ), challenges, eChallengeTimeSpanKind.SEASON_WEEKLY ) )
	}

	return groupData
}
#endif

#if(UI)
array<ItemFlavor> function GetPinnedChallenges()
{
	PlayerChallengesState pcs = GetPlayerChallengesState( GetUIPlayer() )

	array<ItemFlavor> pinnedChallenges
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_IsPinned( challengeFlav ) )
			pinnedChallenges.append( challengeFlav )
	}

	return pinnedChallenges
}
#endif


#if(false)






















//














//


















//































//






//





//












//








//













#endif

#if CLIENT || UI 
PlayerChallengesState function GetPlayerChallengesState( entity player = null )
{
	player = AssertLocalOrServerValidPlayer( player )
	#if(false)

#elseif CLIENT || UI 
		return fileLevel.localPlayerChallengesState
	#endif
}
#endif

#if CLIENT || UI 
void function InitPlayerChallengesStateFromPersistence( entity player, PlayerChallengesState pcs )
{
	if ( !IsValid( player ) )
		return

	#if(DEV)
		if ( DEV_ShouldIgnorePersistence() )
			return
	#endif

	foreach ( ChallengeState ornull cs in pcs.persistentArrayMirror )
	{
		if ( cs == null )
			continue
		expect ChallengeState(cs)
		cs.persistenceIdx = -1
		ItemFlavor badItemFlav
		cs.flav = badItemFlav
	}
	pcs.persistentArrayMirror.clear()
	pcs.persistentArrayMirror.resize( NUM_CHALLENGES_MAX, null )
	pcs.challengeStateMap.clear()

	#if(false)

#endif

	for ( int persistentArrayIdx = 0 ; persistentArrayIdx < NUM_CHALLENGES_MAX ; persistentArrayIdx++ )
	{
		int guid                        = player.GetPersistentVarAsInt( "challenges[" + persistentArrayIdx + "].guid" )
		ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
		if ( challengeFlav == null )
		{
			if ( guid > 0 )
			{
				#if(false)
//




#endif
			}
			continue
		}
		expect ItemFlavor( challengeFlav )

		ChallengeState cs
		cs.persistenceIdx = persistentArrayIdx
		cs.flav = challengeFlav
		pcs.challengeStateMap[cs.flav] <- cs
		pcs.persistentArrayMirror[persistentArrayIdx] = cs
	}

	#if(false)


#endif
}
#endif

#if CLIENT || UI 
bool function Challenge_IsChallengesStateInititated( entity player )
{
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return pcs.challengeStateMap.len() > 0
}
#endif

#if(false)





































#endif

#if(false)



















#endif

#if(false)









//
//



//



















//





//












//



















//












//










//















//



















































































































































































//






//


//

























//






//
























//






//


























#endif


#if(false)





































//









//
//




















//














#endif


#if(false)




//














































#endif


#if(false)













//









//











//












#endif


#if(false)








































































//


//




















//










































//







//












#endif


#if(false)





//














































#endif


#if(false)


































#endif


#if(false)



















#endif


#if(false)


//























//



//











//
//





#endif


#if(false)





























#endif


#if(false)














#endif


#if(false)








//


#endif


#if(false)








//


#endif


#if(false)










//






#endif


#if UI || CLIENT 
#if(DEV)
void function PrintChallengePersistence( entity player )
{
	printt( "---------------------------" )
	printt( "CHALLENGES PERSISTENCE DUMP" )
	printt( "---------------------------" )
	printt( "" )
	printt( "dailyExpirationTime:", player.GetPersistentVarAsInt( "dailyExpirationTime" ) )
	printt( "weeklyRecurringLastResetWeek:", player.GetPersistentVarAsInt( "weeklyRecurringLastResetWeek" ) )
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
		printt( "    ", player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" ) )
	printt( "" )
	printt( "  Assigned Challenges" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid                    = player.GetPersistentVarAsInt( "challenges[" + i + "].guid" )
		ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )

		if ( IsValid( challenge ) )
		{
			printt( "   ", i, ItemFlavor_GetHumanReadableRef( expect ItemFlavor( challenge ) ) )
			printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarker" ) )
			printt( "       currentTier:", player.GetPersistentVarAsInt( "challenges[" + i + "].currentTier" ) )
		}
		else
		{
			printt( "   ", i, guid )
		}
	}

	printt( "" )
	printt( "  Post Game Challenges" )
	printt( "" )

	printt( "  postgameGrindStartTier:", player.GetPersistentVarAsInt( "postgameGrindStartTier" ) )
	printt( "  postgameGrindStartValue:", player.GetPersistentVarAsInt( "postgameGrindStartValue" ) )

	for ( int i = 0 ; i < NUM_POST_GAME_CHALLENGES_MAX ; i++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallenges[" + i + "].guid" )
		if ( guid > 0 )
		{
			ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( IsValid( challenge ) )
			{
				printt( "   ", i, ItemFlavor_GetHumanReadableRef( expect ItemFlavor( challenge ) ) )
				printt( "       completedTier:", player.GetPersistentVarAsInt( "postGameChallenges[" + i + "].completedTier" ) )
				printt( "       statMarkerMatchStart:", player.GetPersistentVarAsInt( "postGameChallenges[" + i + "].statMarkerMatchStart" ) )
			}
		}
		else
		{
			printt( "   ", i, guid )
		}
	}

	printt( "" )
	printt( "  Post Game Challenges Any Progress" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].guid" )
		if ( guid > 0 )
		{
			ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( IsValid( challenge ) )
			{
				printt( "   ", i, ItemFlavor_GetHumanReadableRef( expect ItemFlavor( challenge ) ) )
				printt( "       tierMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].tierMatchStart" ) )
				printt( "       progressMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].progressMatchStart" ) )
			}
		}
		else
		{
			printt( "   ", i, guid )
		}
	}


	printt( "" )
	printt( "---------------------------" )
	printt( "---------------------------" )
}
#endif
#endif //


#if CLIENT && ( DEV || ASSERTING ) 
void function PrintAllChallenges( bool currentBPOnly = false, int timeSpanKind = eChallengeTimeSpanKind.SEASON_WEEKLY, int group = 0 )
{
	array<ItemFlavor> allChallenges = GetAllChallenges()

	if ( currentBPOnly )
	{
		allChallenges.clear()
		ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
		if ( activeBattlePass == null )
			return

		expect ItemFlavor( activeBattlePass )

		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, timeSpanKind, group ) )
	}

	array<string> guid           = []
	array<string> ref            = []
	array<string> desc           = []
	array<string> xpReward       = []
	array<string> bpLevelsReward = []
	array<string> type           = []
	array<string> difficulty     = []

	int guidLen           = 0
	int refLen            = 0
	int descLen           = 0
	int xpRewardLen       = 0
	int bpLevelsRewardLen = 0
	int typeLen           = 0
	int diffLen           = 0

	printt( "------- ALL CHALLENGES -------" )
	foreach ( ItemFlavor challenge in allChallenges )
	{
		if ( !GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challenge ) ), true ) )
			continue

		string _type = GetEnumString( "eChallengeTimeSpanKind", Challenge_GetTimeSpanKind( challenge ) )

		int tierCount = Challenge_GetTierCount( challenge )
		for ( int i = 0 ; i < tierCount ; i++ )
		{
			string _guid = (i == 0) ? ItemFlavor_GetGUIDString( challenge ) : ""
			string _ref  = (i == 0) ? ItemFlavor_GetHumanReadableRef( challenge ) : ""

			string _desc = Challenge_GetDescription( challenge, i )
			_desc = StringReplace( _desc, "`1", "" )
			_desc = StringReplace( _desc, "`0", "" )
			_desc = StringReplace( _desc, "\n", " " )
			if ( tierCount > 1 )
				_desc = (i + 1) + ") " + _desc

			string _xpReward       = format( "   Stars: %d", Challenge_GetBPGrindPointsReward( challenge, i ) )
			string _bpLevelsReward = format( "   BP Levels: %d", Challenge_GetBattlepassLevelsReward( challenge, i ) )

			string _diff = ""
			int _diffInt = Challenge_GetDifficulty( challenge )
			foreach ( key, val in eChallegeDifficulty )
			{
				if ( val == _diffInt )
					_diff = key
			}

			guid.append( _guid )
			ref.append( _ref )
			desc.append( _desc )
			xpReward.append( _xpReward )
			bpLevelsReward.append( _bpLevelsReward )
			type.append( i == 0 ? _type : "" )
			difficulty.append( _diff )

			if ( _guid.len() > guidLen )
				guidLen = _guid.len()
			if ( _ref.len() > refLen )
				refLen = _ref.len()
			if ( _desc.len() > descLen )
				descLen = _desc.len()
			if ( _xpReward.len() > xpRewardLen )
				xpRewardLen = _xpReward.len()
			if ( _bpLevelsReward.len() > bpLevelsRewardLen )
				bpLevelsRewardLen = _bpLevelsReward.len()
			if ( _type.len() > typeLen )
				typeLen = _type.len()
			if ( _diff.len() > diffLen )
				diffLen = _diff.len()
		}
	}

	Assert( desc.len() == ref.len() && xpReward.len() == ref.len() && bpLevelsReward.len() == ref.len() && type.len() == ref.len() )

	for ( int i = 0 ; i < ref.len() ; i++ )
	{
		string _guid           = guid[i]
		string _ref            = ref[i]
		string _desc           = desc[i]
		string _xpReward       = xpReward[i]
		string _bpLevelsReward = bpLevelsReward[i]
		string _type           = type[i]
		string _diff           = difficulty[i]

		while( _guid.len() < guidLen )
			_guid += " "
		while( _ref.len() < refLen )
			_ref += " "
		while( _desc.len() < descLen )
			_desc += " "
		while( _xpReward.len() < xpRewardLen )
			_xpReward += " "
		while( _bpLevelsReward.len() < bpLevelsRewardLen )
			_bpLevelsReward += " "
		while( _type.len() < typeLen )
			_type += " "
		while( _diff.len() < diffLen )
			_diff += " "

		printl( format( "%s  %s  %s  %s  %s  %s  %s", _guid, _ref, _desc, _xpReward, _bpLevelsReward, _type, _diff ) )
	}

	printt( "------------------------------" )
	printt( "  Total Challenges:", allChallenges.len() )
	printt( "------------------------------" )
}
#endif


#if CLIENT || UI 
array<ItemFlavor> function GetAssignedChallengesByTimeSpan( entity player, int timeSpan, int weekIndex = -1 )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpan( challengeFlav ) == timeSpan )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY && Challenge_GetWeekNumber( challengeFlav ) != weekIndex )
				continue

			results.append( challengeFlav )
		}
	}
	return results
}

bool function IsChallengePlaylistEnabled( ItemFlavor challengeFlav )
{
	return GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challengeFlav ) ), true )
}
#endif










#if(UI)
void function UpdateChallengeBoxRowButtons( entity player, array<ItemFlavor> challenges, array<var> buttons )
{
	array<var> buttonRuis
	foreach ( int buttonIdx, var button in buttons )
	{
		//
		Hud_Show( button )

		var rui = Hud_GetRui( button )
		buttonRuis.append( rui )

		RuiSetBool( rui, "challengeCanClickToReroll", false )

		if ( challenges.len() <= buttonIdx )
		{
			RuiSetBool( rui, "isVisible", false )
			Hud_SetEnabled( button, false )
			Hud_ClearToolTipData( button )
			continue
		}

		ItemFlavor challenge     = challenges[ buttonIdx ]
		bool isChallengeComplete = Challenge_IsComplete( player, challenge )     //

		Hud_Show( button )
		RuiSetBool( rui, "isVisible", true )

		int activeTier = Challenge_GetCurrentTier( player, challenge )
		if ( isChallengeComplete )
			activeTier = activeTier - 1 //

		bool canReroll = Challenge_CanRerollChallenge( challenge ) && !isChallengeComplete
		RuiSetBool( rui, "challengeCanClickToReroll", canReroll )
		MaybeAddChallengeClickEventToButton( GetMenu( "LobbyMenu" ), button, challenge, activeTier, canReroll, isChallengeComplete )
	}

	UpdateChallengeRowsRui( player, challenges, buttonRuis )
}
#endif

#if CLIENT || UI 
void function UpdateChallengeRowsRui( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	//
	Assert( challenges.len() <= 5 )

	foreach ( int rowIdx, var rui in rowRuis )
	{
		if ( challenges.len() <= rowIdx )
		{
			//
			RuiSetBool( rui, "isVisible", false )
			continue
		}

		RuiSetBool( rui, "isVisible", true )

		#if(CLIENT)
			//
			RuiSetInt( rui, "rowIndex", rowIdx )
		#endif

		ItemFlavor challenge     = challenges[ rowIdx ]
		int tierCount            = Challenge_GetTierCount( challenge ) //
		int activeTier           = Challenge_GetCurrentTier( player, challenge ) //
		bool isChallengeComplete = Challenge_IsComplete( player, challenge )     //
		if ( isChallengeComplete )
			activeTier = tierCount - 1 //
		bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )    //

		int progress = Challenge_GetProgressDisplayValue( player, challenge, activeTier )
		int goal     = Challenge_GetGoalDisplayVal( challenge, activeTier )

		bool withTierDescPrefix = true //
		int maxRewardIcons      = MAX_REWARDS_PER_CHALLENGE_TIER //

		SetSeasonColors( rui ) //

		vector rewardColor = <1, 1, 1> //
		int timeSpan       = Challenge_GetTimeSpan( challenge )
		if ( timeSpan == eChallengeTimeSpanKind.EVENT )
		{
			ItemFlavor eventFlav = Challenge_GetSource( challenge )
			rewardColor = BuffetEvent_GetRewardIconCol( eventFlav )
		}
		RuiSetFloat3( rui, "rewardColor", rewardColor )

		RuiSetString( rui, "challengeTierDesc", Challenge_GetDescription( challenge, activeTier, withTierDescPrefix ) )

		#if(DEV)
			bool doDebug = (InputIsButtonDown( KEY_LSHIFT ) && InputIsButtonDown( KEY_LCONTROL )) || (InputIsButtonDown( BUTTON_TRIGGER_LEFT_FULL ) && InputIsButtonDown( BUTTON_B ))
			if ( doDebug )
			{
				printt( "#challenge --", ItemFlavor_GetHumanReadableRef( challenge ) )
				RuiSetString( rui, "challengeTierDesc", ItemFlavor_GetHumanReadableRef( challenge ) + " | " + activeTier )
			}
		#endif


		RuiSetInt( rui, "challengeTierProgress", progress )
		RuiSetInt( rui, "challengeTierGoal", goal )
		RuiSetBool( rui, "challengeCompleted", isChallengeComplete )

		bool showDiagonalWeapons                  = false //
		bool shouldUseBadgeRuis                   = false //
		array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, activeTier, showDiagonalWeapons, shouldUseBadgeRuis, false )
		if ( rewards.len() >= maxRewardIcons )
			Warning( "Too many rewards for one challenge: " + ItemFlavor_GetHumanReadableRef( challenge ) )

		for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
		{
			string ruiArgPrefix = "challengeTierReward" + rewardIdx
			if ( rewardIdx < rewards.len() )
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, rewards[ rewardIdx ] )
			else
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, null )
		}
	}
}
#endif

#if(UI)
void function UpdateChallengeBoxHeader( entity player, var challengesBoxHeader, ItemFlavor ornull eventFlav )
{
	var rui = Hud_GetRui( challengesBoxHeader )
	Assert( rui != null )

	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )
	RuiSetInt( rui, "bpStarCount", -1 )
	RuiSetBool( rui, "showBPProgress", false )
	RuiSetString( rui, "headerText", "" )
	RuiSetString( rui, "subText", "" )
	RuiSetString( rui, "challengeCategoryString", "" )
	RuiSetImage( rui, "headerImage", $"" )
	RuiSetFloat3( rui, "textColor1", <1.0, 1.0, 1.0> )
	RuiSetFloat3( rui, "textColor2", <0.7, 0.7, 0.7> )

	RemoveChallengeFocusEventToButton( challengesBoxHeader )
	RemoveChallengeClickEventToButton( challengesBoxHeader )

	switch( GetChallengeDisplayCategory() )
	{
		case eChallengeCategory.DAILY:
			UpdateChallengeBoxBPLevelBadge( player, rui )
			UpdateChallengeBoxHeaderBPProgress( player, rui )

			RuiSetString( rui, "headerText", "" )
			RuiSetString( rui, "subText", "" )
			RuiSetString( rui, "challengeCategoryString", "#CATEGORY_DAILY_CHALLENGES" )

			int remainingDuration = GetPersistentVarAsInt( "dailyExpirationTime" ) - Daily_GetCurrentTime()
			RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? Time() + remainingDuration : RUI_BADGAMETIME )
			RuiSetBool( rui, "eventActive", false )

			break

		case eChallengeCategory.EVENT:
			Assert( eventFlav != null )
			expect ItemFlavor( eventFlav )
			Assert( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )

			asset nestedAsset = $"ui/themed_shop_event_challenge_header_icon.rpak"
			var nestedHandle = RuiCreateNested( rui, "headerBadgeHandle", nestedAsset )
			RuiSetAsset( nestedHandle, "headerIcon", BuffetEvent_GetHeaderIcon( eventFlav ) )

			RuiSetString( rui, "headerText", ItemFlavor_GetShortName( eventFlav ) )

			vector textColor1 = BuffetEvent_GetHeaderTextCol1( eventFlav )
			vector textColor2 = BuffetEvent_GetHeaderTextCol2( eventFlav )
			RuiSetFloat3( rui, "textColor1", textColor1 )
			RuiSetFloat3( rui, "textColor2", textColor2 )

			RuiSetString( rui, "subText", "" )
			RuiSetString( rui, "challengeCategoryString", "#CATEGORY_EVENT_CHALLENGES" )
			UpdateChallengeBoxButtonEvent( challengesBoxHeader, eventFlav )

			int endTime = CalEvent_GetFinishUnixTime( eventFlav )
			int remainingDuration = endTime - GetUnixTimestamp()

			asset headerImage = BuffetEvent_GetChallengeHeaderImage( eventFlav )
			//

			RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? Time() + remainingDuration : RUI_BADGAMETIME )
			RuiSetBool( rui, "eventActive", true )
			RuiSetImage( rui, "headerImage", headerImage )

			break

		case eChallengeCategory.TOP_WEEKLY:
			UpdateChallengeBoxBPLevelBadge( player, rui )
			UpdateChallengeBoxHeaderBPProgress( player, rui )

			RuiSetString( rui, "headerText", "" )
			RuiSetString( rui, "subText", "" )
			RuiSetString( rui, "challengeCategoryString", "#CATEGORY_TOP_WEEKLY_CHALLENGES" )

			RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
		RuiSetBool( rui, "eventActive", false )

			break
	}
}
#endif

#if CLIENT || UI 
void function UpdateChallengeBoxBPLevelBadge( entity player, var rui )
{
	EHI playerEHI                      = ToEHI( player )
	ItemFlavor ornull activeBattlePass = GetPlayerLastActiveBattlePass( playerEHI )
	if ( activeBattlePass != null && rui != null )
	{
		expect ItemFlavor( activeBattlePass )

		int currentBattlePassXP  = GetPlayerBattlePassXPProgress( playerEHI, activeBattlePass, false )
		int battlePassLevel      = GetBattlePassLevelForXP( activeBattlePass, currentBattlePassXP ) + 1
		bool battlePassCompleted = battlePassLevel >= (GetBattlePassMaxLevelIndex( activeBattlePass ) + 1)

		SetBattlePassLevelBadgeForLevel( player, rui, activeBattlePass, battlePassLevel, battlePassCompleted )
	}
}
void function SetBattlePassLevelBadgeForLevel( entity player, var rui, ItemFlavor activeBattlePass, int battlePassLevel, bool battlePassCompleted )
{
	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )

	EHI playerEHI                        = ToEHI( player )
	ItemFlavor headerBadge               = GetBattlePassProgressBadge( activeBattlePass )
	int ornull overrideDataIntegerOrNull = battlePassLevel

	ItemFlavor dummy
	CreateNestedGladiatorCardBadge( rui, "headerBadgeHandle", playerEHI, headerBadge, 0, dummy, overrideDataIntegerOrNull )

	RuiSetBool( rui, "battlePassCompleted", battlePassCompleted )

	if ( battlePassCompleted )
		RuiSetImage( rui, "headerImage", BATTLE_COMPLETED_HEADER_IMAGE )
	else
		RuiSetImage( rui, "headerImage", $"" )
}
#endif

#if CLIENT || UI 
void function UpdateChallengeBoxHeaderBPProgress( entity player, var rui )
{
	ItemFlavor ornull activeBattlePass = GetActiveBattlePass()

	if ( activeBattlePass != null )
	{
		expect ItemFlavor( activeBattlePass )

		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )

			if ( starChallenge != null )
			{
				expect ItemFlavor( starChallenge )

				if ( DoesPlayerHaveChallenge( player, starChallenge ) )
				{
					SetSeasonColors( rui )

					int tier     = Challenge_GetCurrentTier( player, starChallenge )
					int progress = Challenge_GetProgressValue( player, starChallenge, tier )
					RuiSetInt( rui, "bpStarCount", progress )
					RuiSetBool( rui, "showBPProgress", true )
				}
			}
		}
	}
}
#endif

#if(UI)
void function UpdateEventTrackButton( entity player, var button, ItemFlavor ornull eventFlav )
{
	//
	RemoveChallengeClickEventToButton( button )
	bool showButton = false
	if ( button != null )
	{
		if ( eventFlav != null )
		{
			expect ItemFlavor( eventFlav )

			if ( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )
			{
				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					BuffetEvent_OnLobbyPlayPanelSpecialChallengeClicked( eventFlav )
				})

				Hud_AddEventHandler( button, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[button] <- headerClickHandler
				showButton = true

				asset buttonImage = BuffetEvent_GetChallengeButtonImage( eventFlav )
				vector textColor  = BuffetEvent_GetAboutPageScoreCol( eventFlav )

				var rui = Hud_GetRui( button )
				RuiSetImage( rui, "buttonImage", buttonImage )
				RuiSetFloat3( rui, "textColor", textColor )
			}
		}
	}

	if ( showButton )
		Hud_Show( button )
	else
		Hud_Hide( button )
}
#endif

#if(UI)
void function UpdateChallengeBoxButtonEvent( var mainElem, ItemFlavor ornull eventFlav )
{
	//

	RemoveChallengeFocusEventToButton( mainElem )
	RemoveChallengeClickEventToButton( mainElem )

	if ( mainElem != null )
	{
		if ( eventFlav != null )
		{
			expect ItemFlavor( eventFlav )

			if ( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )
			{
				void functionref(var) headerFocusHandler = (void function( var button ) : () {
					EmitUISound( "ui_menu_focus" )
				})

				Hud_AddEventHandler( mainElem, UIE_GET_FOCUS, headerFocusHandler )
				WORKAROUND_challengeButtonToFocusHandlerMap[mainElem] <- headerFocusHandler

				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					BuffetEvent_OnLobbyPlayPanelSpecialChallengeClicked( eventFlav )
				})

				Hud_AddEventHandler( mainElem, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[mainElem] <- headerClickHandler
			}
		}
	}
}
#endif //

#if(UI)
void function UpdateChallengeBoxHeaderReward( entity player, var rewardButton )
{
	BattlePassReward ornull reward
	ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
	int category                       = GetChallengeDisplayCategory()

	if ( activeBattlePass != null && category != eChallengeCategory.EVENT )
	{
		expect ItemFlavor( activeBattlePass )
		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			int battlePassLevel = GetPlayerBattlePassLevel( player, activeBattlePass, false ) + 1
			reward = TrySetBattlePassRewardOnButton( rewardButton, activeBattlePass, battlePassLevel )
		}
	}

	Hud_Hide( rewardButton )
	file.nextBattlePassReward = null

	if ( reward != null )
	{
		Hud_Show( rewardButton )
		expect BattlePassReward( reward )
		if ( InspectItemTypePresentationSupported( reward.flav ) )
			file.nextBattlePassReward = reward
	}
}

void function ChallengeInspectNextReward( var button )
{
	if ( file.nextBattlePassReward == null )
		return

	BattlePassReward rewardData = expect BattlePassReward( file.nextBattlePassReward )
	SetBattlePassItemPresentationModeActive( rewardData )
}


BattlePassReward ornull function TrySetBattlePassRewardOnButton( var rewardButton, ItemFlavor battlePass, int battlePassLevel, bool showFreeReward = false )
{
	BattlePassReward ornull rewardToShow
	array<BattlePassReward> rewards = GetBattlePassLevelRewards( battlePass, battlePassLevel )
	int maxLevel                    = GetBattlePassMaxLevelIndex( battlePass )
	while( rewards.len() == 0 && battlePassLevel < maxLevel )
	{
		battlePassLevel++
		rewards = GetBattlePassLevelRewards( battlePass, battlePassLevel )
	}

	foreach ( reward in rewards )
	{
		if ( showFreeReward )
		{
			if ( reward.isPremium )
				continue
			rewardToShow = reward //
			break
		}

		if ( !reward.isPremium )
			continue

		rewardToShow = reward //
		break
	}

	if ( rewardToShow != null )
	{
		expect BattlePassReward( rewardToShow )
		BattlePass_PopulateRewardButton( rewardToShow, rewardButton, false, true, null )
	}

	return rewardToShow
}
#endif


bool function Challenge_CanRerollChallenge( ItemFlavor challenge )
{
	if ( Challenge_GetTimeSpan( challenge ) != eChallengeTimeSpanKind.DAILY )
		return false

	array<ItemFlavor> dailyChallengePool = clone GetAllChallengesOfTimespan( eChallengeTimeSpanKind.DAILY )
	array<ItemFlavor> rerollPool

	int diff = Challenge_GetDifficulty( challenge )

	foreach ( ch in dailyChallengePool )
	{
		if ( Challenge_GetDifficulty( ch ) == diff )
			rerollPool.append( ch )
	}

	if ( rerollPool.len() <= 1 )
		return false

	return true
}
















#if CLIENT || UI 
void function SetRuiArgsForChallengeTier( var rui, string ruiArgPrefix, ItemFlavor challenge, int ornull displayTierIdx, bool withTierDescPrefix, int maxRewardIcons, int maxExtraRewardIcons )
{
	//
	//

	entity player = GetLocalClientPlayer()
	string p      = ruiArgPrefix

	int challengeTierCount   = Challenge_GetTierCount( challenge )
	bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )
	int currentTierIdx       = Challenge_GetCurrentTier( player, challenge )
	if ( displayTierIdx == null )
		displayTierIdx = currentTierIdx
	expect int(displayTierIdx)
	displayTierIdx = ClampInt( displayTierIdx, 0, challengeTierCount - 1 )

	int progress = Challenge_GetProgressDisplayValue( player, challenge, displayTierIdx ) //
	int goal     = Challenge_GetGoalDisplayVal( challenge, displayTierIdx ) //

	ItemFlavor ornull season = GetActiveSeason( GetUnixTimestamp() )

	RuiSetInt( rui, p + "TiersCount", challengeTierCount )
	RuiSetBool( rui, p + "IsInfinite", challengeIsInfinite )
	RuiSetInt( rui, p + "ActiveTierIdx", currentTierIdx )
	RuiSetString( rui, p + "TierDesc", Challenge_GetDescription( challenge, displayTierIdx, withTierDescPrefix ) )
	RuiSetInt( rui, p + "TierProgress", progress )
	RuiSetInt( rui, p + "TierGoal", goal )
	RuiSetBool( rui, p + "Completed", Challenge_IsComplete( player, challenge ) )

	SetSeasonColors( rui )

	bool showDiagonalWeapons                  = false
	bool shouldUseBadgeRuis                   = false
	array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, displayTierIdx, showDiagonalWeapons, shouldUseBadgeRuis, true )

	int bestRarityTier = -1
	for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
	{
		if ( rewardIdx < rewards.len() )
		{
			ChallengeRewardDisplayData crdd = rewards[rewardIdx]
			bestRarityTier = maxint( bestRarityTier, crdd.rarityTier )
			if ( rewardIdx >= maxRewardIcons )
			{
				if ( maxRewardIcons > 0 )
					Warning( "Too many rewards for one challenge tier. RUI will not display reward with icon: %s", string(crdd.icon) )
				continue //
			}

			SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), crdd )

			continue //
		}
		else if ( rewardIdx >= maxRewardIcons )
			continue //

		//
		SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), null )
	}

	RuiSetInt( rui, p + "TierBestRarityTier", bestRarityTier )
}

void function SetRuiArgsForChallengeReward( var rui, string ruiArgPrefix, ChallengeRewardDisplayData ornull crdd )
{
	//
	string p = ruiArgPrefix

	RuiDestroyNestedIfAlive( rui, format( "%sUi", p ) )

	if ( crdd == null )
	{
		RuiSetInt( rui, format( "%sStyle", p ), -1 )
		RuiSetInt( rui, format( "%sRarityTier", p ), -1 )
		RuiSetImage( rui, format( "%sIcon", p ), $"" )
		RuiSetString( rui, format( "%sTinyLabelText", p ), "" )
		RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), -1 )
		return
	}
	expect ChallengeRewardDisplayData(crdd)

	RuiSetInt( rui, format( "%sStyle", p ), crdd.style )
	RuiSetInt( rui, format( "%sRarityTier", p ), crdd.rarityTier )
	RuiSetImage( rui, format( "%sIcon", p ), crdd.icon )
	if ( crdd.badgeFlav != null )
	{
		CreateNestedGladiatorCardBadge( rui, format( "%sUi", p ), LocalClientEHI(),
			expect ItemFlavor(crdd.badgeFlav), -1, null, crdd.badgeTier, false ) //
	}
	RuiSetString( rui, format( "%sTinyLabelText", p ), crdd.tinyLabelText )
	RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), crdd.tinyLabelPlacementStyle )
}


array<ChallengeRewardDisplayData> function GetChallengeRewardDisplayData( ItemFlavor challenge, int tierIdx, bool showDiagonalWeapons, bool shouldUseBadgeRuis, bool tinyLabelToTheLeft )
{
	array<ChallengeRewardDisplayData> displayData = []

	ItemFlavorBag rewards = Challenge_GetRewards( challenge, tierIdx )
	foreach ( int itemIdx, ItemFlavor flav in rewards.flavors )
	{
		ChallengeRewardDisplayData crdd
		crdd.flav = flav
		crdd.originalQuantity = rewards.quantities[itemIdx]
		crdd.displayQuantity = crdd.originalQuantity
		crdd.style = eChallengeRewardStyle.ITEM_GENERAL
		crdd.rarityTier = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
		crdd.icon = CustomizeMenu_GetRewardButtonImage( flav )
		crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE

		if ( ItemFlavor_GetType( flav ) == eItemType.voucher )
		{
			bool foundQuantity = false
			if ( Voucher_GetEffectBattlepassGrindPoints( flav ) > 0 )
			{
				foundQuantity = true
				crdd.displayQuantity *= Voucher_GetEffectBattlepassGrindPoints( flav )

				//
				ItemFlavor ornull battlePass = GetActiveBattlePass()
				if ( battlePass != null )
				{
					expect ItemFlavor( battlePass )
					//
				}

				if ( tinyLabelToTheLeft )
					crdd.tinyLabelText = Localize( "#PLUS_N", LocalizeNumber( string(crdd.displayQuantity) ) )
				else
					crdd.tinyLabelText = LocalizeNumber( string(crdd.displayQuantity) )
				crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE
				crdd.icon = $"rui/menu/challenges/challenges_icon_star_padded"
			}
			else if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) > 0 )
			{
				crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			}

			if ( Voucher_GetEffectBattlepassStars( flav ) > 0 )
			{
				crdd.displayQuantity *= Voucher_GetEffectBattlepassStars( flav )
				if ( tinyLabelToTheLeft )
				{
					crdd.tinyLabelText = Localize( "#PLUS_N", LocalizeNumber( string(crdd.displayQuantity) ) )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
				}
				else
				{
					crdd.tinyLabelText = LocalizeNumber( string(crdd.displayQuantity) )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
				}
			}

			if ( Voucher_GetEffectBattlepassLevels( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectBattlepassLevels( flav )
					crdd.icon = $"rui/menu/challenges/challenges_icon_levelup"

					//
					crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.NONE
					crdd.tinyLabelText = tinyLabelToTheLeft ? Localize( "#PLUS_N", LocalizeNumber( string(crdd.displayQuantity) ) ) : ""
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) != 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectStatAmount( flav )

					asset voucherImage = ItemFlavor_GetIcon( flav )
					if ( voucherImage != $"" )
						crdd.icon = voucherImage
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.weapon_skin )
		{
			if ( showDiagonalWeapons )
			{
				crdd.style = eChallengeRewardStyle.ITEM_WEAPON_SKIN
				crdd.icon = WeaponItemFlavor_GetHudIcon( WeaponSkin_GetWeaponFlavor( flav ) )
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.gladiator_card_badge )
		{
			if ( shouldUseBadgeRuis )
			{
				crdd.style = eChallengeRewardStyle.ITEM_BADGE
				crdd.icon = $""
				crdd.badgeFlav = flav
			}

			//
			int badgeTier = 0
			for ( int prevTierIdx = 0; prevTierIdx < tierIdx; prevTierIdx++ )
			{
				ItemFlavorBag prevTierRewards = Challenge_GetRewards( challenge, prevTierIdx )
				if ( prevTierRewards.flavors.contains( flav ) )
					badgeTier++
			}

			crdd.badgeTier = badgeTier
		}

		if ( crdd.tinyLabelText == "" )
			crdd.tinyLabelText = crdd.displayQuantity > 1 ? LocalizeNumber( string(crdd.displayQuantity) ) + "x" : ""

		displayData.append( crdd )
	}

	/*










*/
	return displayData
}
#endif


#if(UI)
void function RemoveChallengeClickEventToButton( var button )
{
	if ( button in WORKAROUND_challengeButtonToClickHandlerMap )
	{
		Hud_RemoveEventHandler( button, UIE_CLICK, WORKAROUND_challengeButtonToClickHandlerMap[button] )
		delete WORKAROUND_challengeButtonToClickHandlerMap[button]
	}
}

void function RemoveChallengeFocusEventToButton( var button )
{
	if ( button in WORKAROUND_challengeButtonToFocusHandlerMap )
	{
		Hud_RemoveEventHandler( button, UIE_GET_FOCUS, WORKAROUND_challengeButtonToFocusHandlerMap[button] )
		delete WORKAROUND_challengeButtonToFocusHandlerMap[button]
	}
}

void function MaybeAddChallengeClickEventToButton( var menu, var button, ItemFlavor challenge, int activeTier, bool canReroll, bool isChallengeComplete )
{
	//
	//
	//
	//
	bool addButtonClickEvent = false

	void functionref(var) clickHandler
	ToolTipData toolTipData

	if ( canReroll )
	{
		addButtonClickEvent = true

		clickHandler = (void function( var button ) : ( challenge, activeTier, menu ) {
		ItemFlavor ornull activeBattlePass = GetActiveBattlePass()

		if ( !GRX_IsInventoryReady() )
			return

		if ( activeBattlePass == null )
			return

		if ( !GRX_IsInventoryReady() )
			return

		if ( !GRX_AreOffersReady() )
			return

		expect ItemFlavor( activeBattlePass )

		ItemFlavor rerollFlav = BattlePass_GetRerollFlav( activeBattlePass )

		int numTokens         = GRX_GetConsumableCount( ItemFlavor_GetGRXIndex( rerollFlav ) )
		string persistenceKey = "challengeRerollsUsed"
		int tokensUsed        = GetPersistentVarAsInt( persistenceKey )

		Assert( tokensUsed <= numTokens )

		int currentDailyRerollCount = GetPersistentVarAsInt( "dailyRerollCount" )
		int numNeeded               = REROLL_COSTS[ minint( currentDailyRerollCount, REROLL_COSTS.len() - 1 ) ]

		if ( numTokens - tokensUsed < numNeeded )
		{
			int tier             = Challenge_GetCurrentTier( GetUIPlayer(), challenge )
			string challengeText = Challenge_GetDescription( challenge, tier )
			challengeText = StripRuiStringFormatting( challengeText )

			ItemFlavorPurchasabilityInfo ifpi = GRX_GetItemPurchasabilityInfo( challenge )

			GRXScriptOffer offer
			array<GRXScriptOffer> offers
			foreach ( string location, array<GRXScriptOffer> locationOfferList in ifpi.locationToDedicatedStoreOffersMap )
				foreach ( GRXScriptOffer locationOffer in locationOfferList )
					offers.append( locationOffer )

			var rui = Hud_GetRui( button )
			PurchaseDialogConfig pdc
			pdc.flav = rerollFlav
			pdc.messageOverride = Localize( "#PURCHASE_REROLL_MSG", Localize( challengeText ) )
			pdc.quantity = numNeeded
			pdc.markAsNew = false
			pdc.onPurchaseResultCallback = void function( bool wasSuccessful ) : ( challenge, rui, menu ) {
				if ( menu == null )
					JumpToChallenges()

				if ( wasSuccessful )
				{
					Remote_ServerCallFunction( "ClientCallback_Challenge_ReRoll", ItemFlavor_GetGUID( challenge ) )
					delaythread( 1.65 ) ShimmerChallenge( rui, menu )
				}
			}
			PurchaseDialog( pdc )
		}
		else
		{
			int tier             = Challenge_GetCurrentTier( GetUIPlayer(), challenge )
			string challengeText = Challenge_GetDescription( challenge, tier )
			challengeText = StripRuiStringFormatting( challengeText )

			ConfirmDialogData data
			data.headerText = Localize( "#PURCHASE_REROLL_MSG", Localize( challengeText ) )
			data.messageText = "#PURCHASE_REROLL_TITLE"
			data.yesText = ["#GAMEUI_YES", "#GAMEUI_YES"]
			data.noText = ["#GAMEUI_NO", "#GAMEUI_NO"]

			data.resultCallback = void function ( int result ) : ( challenge, button, menu )
			{
				if ( menu == null )
					JumpToChallenges()

				if ( result == eDialogResult.YES )
				{
					var rui = Hud_GetRui( button )
					//
					Remote_ServerCallFunction( "ClientCallback_Challenge_ReRoll", ItemFlavor_GetGUID( challenge ) )
					ShimmerChallenge( rui, menu )
					return
				}
			}

			if ( !IsDialog( GetActiveMenu() ) )
				OpenConfirmDialogFromData( data )
		}
	})

	//
	toolTipData.tooltipStyle = eTooltipStyle.BUTTON_PROMPT
	toolTipData.actionHint1 = "#REROLL_TOOLTIP"
	}
	else
	{
		ItemFlavorBag challengeRewards = Challenge_GetRewards( challenge, activeTier )
		if ( challengeRewards.flavors.len() == 1 && InspectItemTypePresentationSupported( challengeRewards.flavors[0] ) )
		{
			addButtonClickEvent = true

			ItemFlavor singleRewardFlav    = challengeRewards.flavors[0]
			int singleRewardFlavQty        = challengeRewards.quantities[0]

			clickHandler = (void function( var button ) : ( challenge, activeTier, singleRewardFlav, singleRewardFlavQty, isChallengeComplete ) {
				SetChallengeRewardPresentationModeActive( singleRewardFlav, singleRewardFlavQty,
					activeTier,
					"#CHALLENGE_REWARD",
					Challenge_GetDescription( challenge, activeTier ),
					isChallengeComplete
				)
			})

			toolTipData.tooltipStyle = eTooltipStyle.BUTTON_PROMPT
			toolTipData.actionHint1 = "#VIEW_REWARD_TOOLTIP"
		}
	}

	//
	RemoveChallengeClickEventToButton( button )

	if ( addButtonClickEvent )
	{
		Hud_AddEventHandler( button, UIE_CLICK, clickHandler )
		WORKAROUND_challengeButtonToClickHandlerMap[button] <- clickHandler

	Hud_SetToolTipData( button, toolTipData )
}
	else
	{
		Hud_ClearToolTipData( button )
	}

	Hud_SetEnabled( button, addButtonClickEvent )
}

void function ShimmerChallenge( var rui, var menu )
{
	if ( menu == null )
		return

	if ( GetActiveMenu() != menu )
		return

	RuiSetGameTime( rui, "rerollAnimStartTime", Time() )
	EmitUISound( CHALLENGE_REROLL_SOUND )
}
#endif

#if CLIENT || UI 
string function Challenge_GetDescription( ItemFlavor challenge, int tier, bool withTiersPrefix = false )
{
	int tierCount = Challenge_GetTierCount( challenge )
	Assert( tier >= 0 && tier < tierCount )

	int challengeGoal = Challenge_GetGoalVal( challenge, tier )

	var tierData = Challenge_GetTierDataBlock( challenge, tier )

	int challengeDisplay = Challenge_GetGoalDisplayVal( challenge, tier )

	string tierDescription = GetSettingsBlockString( tierData, "description" )

	string ornull result = null

	array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( challenge, tier )
	if ( characterFlavors.len() > 0 )
	{
		switch ( characterFlavors.len() )
		{
			case 1:
				result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ) )
				break

			case 2:
				result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ) )
				break

			case 3:
				result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) ) )
				break

			case 4:
				result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[3] ) ) )
				break

			default:
				Assert( 0, "Invalid number of character flavors referened in challenge " + ItemFlavor_GetHumanReadableRef( challenge ) + " tier " + tier )
				break
		}
	}

	if ( result == null )
	{
		ItemFlavor ornull weaponFlavor = Challenge_GetWeaponItemFlavorOrNull( challenge, tier )
		if ( weaponFlavor != null )
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetShortName( expect ItemFlavor( weaponFlavor ) ) ) )
	}

	if ( result == null )
	{
		//
		string zoneName = Challenge_GetZoneName( challenge, tier )
		if ( zoneName != "" )
			result = Localize( tierDescription, challengeDisplay, Localize( zoneName ) )
	}

	if ( result == null )
		result = Localize( tierDescription, challengeDisplay )

	//
	//

	return expect string(result)
}
#endif


#if CLIENT || UI 
bool function DoesPlayerHaveChallenge( entity player, ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}
#endif


#if(false)







//






























//


//



//





//



//



//







//
//
//
//
//




//
//
//













//
















//
//



//




























#endif


#if(false)
























//





















#endif


#if(false)

































#endif

#if(false)







//





















































//

#endif




#if CLIENT || UI 
bool function IsChallengeTierComplete( entity player, ItemFlavor challenge, int tier )
{
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challenge ) )

	int goalVal  = Challenge_GetGoalVal( challenge, tier )
	int progress = Challenge_GetProgressValue( player, challenge, tier )
	return progress >= goalVal
}
#endif


#if(false)


//




















//







//







//
























//





//





















//






#endif


#if CLIENT || UI 
array<ItemFlavor> function GetAllChallenges()
{
	//
	return GetAllItemFlavorsOfType( eItemType.challenge )
}
#endif


#if CLIENT || UI 
array<ItemFlavor> function GetAllChallengesOfTimespan( int timeSpan, int weekIndex = -1, int forWeek = -1 )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	array<ItemFlavor> results = []

	if ( GetActiveBattlePass() == null && timeSpan != eChallengeTimeSpanKind.EVENT )
		return results

	switch ( timeSpan )
	{
		case eChallengeTimeSpanKind.EVENT:
			foreach ( ItemFlavor challenge in GetAllChallenges() )
			{
				if ( Challenge_GetTimeSpanKind( challenge ) == timeSpan )
				{
					if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY && Challenge_GetWeekNumber( challenge ) != weekIndex )
						continue

					if ( !IsChallengePlaylistEnabled( challenge ) )
						continue

					results.append( challenge )
				}
			}
			break

		case eChallengeTimeSpanKind.SEASON_WEEKLY:
		case eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING:
		case eChallengeTimeSpanKind.DAILY:
			ItemFlavor pass = expect ItemFlavor( GetActiveBattlePass() )
			array<ItemFlavor> challenges
			foreach ( challenge in GetBattlePassChallenges( pass, timeSpan, weekIndex, forWeek ) )
			{
				if ( IsChallengePlaylistEnabled( challenge ) )
					challenges.append( challenge )
			}

			return challenges
			break
	}

	return results
}
#endif

#if(UI)
array<ChallengeProgressData> function GetPlayerChallengesWithNewProgress( entity player )
{
	/*

*/

	array<int> handledGUIDs = []
	array<ChallengeProgressData> progressDataArray

	for ( int index = 0 ; index < NUM_CHALLENGES_MAX ; index++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].guid" )
		if ( guid > 0 )
		{
			//
			if ( handledGUIDs.contains( guid ) )
				continue
			handledGUIDs.append( guid )

			ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( challengeFlav != null )
			{
				expect ItemFlavor( challengeFlav )

				if ( !DoesPlayerHaveChallenge( player, challengeFlav ) )
					continue

				if ( Challenge_ShouldExcludeFromPostMatchSummary( challengeFlav ) )
					continue

				int timeSpanKind      = Challenge_GetTimeSpan( challengeFlav )
				bool isEventChallenge = (timeSpanKind == eChallengeTimeSpanKind.EVENT)

				bool lastTierIsInfinite = Challenge_LastTierIsInfinite( challengeFlav )
				bool isPinned           = Challenge_IsPinned( challengeFlav )
				bool isEventMain
				if ( isEventChallenge )
				{
					ItemFlavor event                         = Challenge_GetSource( challengeFlav )
					BuffetEventModesAndChallengesData bemacd = BuffetEvent_GetModesAndChallengesData( event )
					isEventMain = bemacd.mainChallengeFlav == challengeFlav
				}

				int tierCount = Challenge_GetTierCount( challengeFlav )
				int startTier = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].tierMatchStart" )

				int currentTier = Challenge_GetCurrentTier( player, challengeFlav )
				if ( currentTier == tierCount )
					currentTier -= 1    //

				PlayerChallengesState pcs = GetPlayerChallengesState( player )
				ChallengeState cs         = pcs.challengeStateMap[ challengeFlav ]

				//
				int statMarker      = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )
				int startProgress   = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].progressMatchStart" )
				int currentProgress = 0

				array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier )
				foreach ( string statRef in statRefs )
				{
					StatEntry entry = GetStatEntryByRef( statRef )
					currentProgress += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
				}

				if ( lastTierIsInfinite && startTier == (tierCount - 1) )
				{
					//
					if ( (statMarker <= startProgress) )
					{
						//
						startProgress = startProgress - statMarker
						currentProgress = currentProgress - statMarker
					}
					else
					{
						//
						int _tierGoalProgress = Challenge_GetGoalVal( challengeFlav, startTier )
						int _usedProgress     = statMarker - startProgress
						int _tiersCompleted   = (_usedProgress / _tierGoalProgress) + 1
						_usedProgress = _usedProgress % _tierGoalProgress
						startProgress = _tierGoalProgress - _usedProgress
						currentProgress = currentProgress - statMarker + (_tierGoalProgress * _tiersCompleted)
					}
				}
				else
				{
					//
					startProgress = startProgress - statMarker
					currentProgress = currentProgress - statMarker
				}
				int ogStartProgress = startProgress //

				bool isSingleMatch = Challenge_IsSingleMatch( challengeFlav, startTier )
				if ( Challenge_IsSingleMatch( challengeFlav, startTier ) )
				{
					//
					if ( startProgress < 0 )
						continue
				}

				int remainingProgress = currentProgress - startProgress
				//
				if ( remainingProgress <= 0 )
					continue    //

				ChallengeProgressData PreviousData
				bool shouldGroup

				while( remainingProgress > 0 )
				{
					//
					int tierGoalProgress = Challenge_GetGoalVal( challengeFlav, startTier )
					bool tierCompleted   = startProgress + remainingProgress >= tierGoalProgress
					int usedProgress     = tierCompleted ? tierGoalProgress - startProgress : currentProgress - startProgress
					int endProgress      = startProgress + usedProgress

					var tierData                 = Challenge_GetTierDataBlock( challengeFlav, startTier )
					bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

					//
					ChallengeProgressData challengeProgress
					challengeProgress.challengeFlav = challengeFlav
					challengeProgress.challengeGUID = guid
					challengeProgress.tier = startTier
					challengeProgress.startProgress = displaySecondsAsMinutes ? ConvertSecondsToMinutes( ogStartProgress ) : ogStartProgress
					challengeProgress.endProgress = displaySecondsAsMinutes ? ConvertSecondsToMinutes( endProgress ) : endProgress
					challengeProgress.goalProgress = displaySecondsAsMinutes ? ConvertSecondsToMinutes( tierGoalProgress ): tierGoalProgress
					challengeProgress.isTierCompleted = tierCompleted
					challengeProgress.isEventChallenge = isEventChallenge
					challengeProgress.isEventMain = isEventMain
					challengeProgress.isPinned = isPinned

					//
					if ( shouldGroup )
					{
						//
						Assert( PreviousData.challengeGUID != 0 )
						PreviousData.groupArray.append( challengeProgress )
					}
					else
					{
						progressDataArray.append( challengeProgress )
						PreviousData = challengeProgress
					}

					bool lastTier = startTier == tierCount - 1
					if ( Challenge_ShouldStartAtZero( challengeFlav, startTier ) && lastTierIsInfinite && lastTier )
					{
						currentProgress = currentProgress - endProgress
						startProgress = 0
					}
					else
					{
						startProgress = endProgress
					}

					remainingProgress = remainingProgress - usedProgress //
					if ( lastTier )
					{
						if ( !lastTierIsInfinite )
							remainingProgress = 0 //
						else
							ogStartProgress = 0 //
					}

					startTier++
					if ( startTier == tierCount ) //
						startTier -= 1

					shouldGroup = (remainingProgress > 0)
				}
			}
		}
	}

	progressDataArray.sort( PostMatchChallengeSort )

	#if(DEV)
		printt( "#CHALLENGE POST MATCH DATA" )

		ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
		if ( activeBattlePass != null )
		{
			expect ItemFlavor( activeBattlePass )
			if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
			{
				ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )
				if ( starChallenge != null )
				{
					expect ItemFlavor( starChallenge )
					if ( DoesPlayerHaveChallenge( player, starChallenge ) )
					{
						int currentLevel = GetPlayerBattlePassLevel( player, activeBattlePass, false )
						int prevLevel    = GetPlayerBattlePassLevel( player, activeBattlePass, true )
						int tier         = Challenge_GetCurrentTier( player, starChallenge )
						int progress     = Challenge_GetProgressValue( player, starChallenge, tier )
						int prevProgress = GetStarChallengeProgressStartLastMatch( player, activeBattlePass )
						printt( "\tprev BP level", prevLevel )
						printt( "\tnew BP level", currentLevel )
						printt( "\tprev star count", prevProgress )
						printt( "\tnew star count", progress )
						printt( "\tstar tier", tier )
					}
				}
			}
		}


		printt( "#CHALLENGE POST MATCH SORT ORDER" )
		printt( "\ttier    start   end     goal    done    event   main    challenge" )
		printt( "\t---------------------------------------------------------" )

		foreach ( ChallengeProgressData progressData in progressDataArray )
		{
			if ( !DoesPlayerHaveChallenge( player, progressData.challengeFlav ) )
			{
				Warning( "Tried to check progress on challenge player doesn't have: " + ItemFlavor_GetHumanReadableRef( progressData.challengeFlav ) )
				continue
			}

			printt( "    " + AddPadding( string( progressData.tier ) ) +
			AddPadding( string( progressData.startProgress ) ) +
			AddPadding( string( progressData.endProgress ) ) +
			AddPadding( string( progressData.goalProgress ) ) +
			AddPadding( string( progressData.isTierCompleted ) ) +
			AddPadding( string( progressData.isEventChallenge ) ) +
			AddPadding( string( progressData.isEventMain ) ) +
			ItemFlavor_GetHumanReadableRef( progressData.challengeFlav ) )

			foreach ( int index, ChallengeProgressData groupedProgressData in progressData.groupArray )
			{
				printt( index + 1, "  " + AddPadding( string( groupedProgressData.tier ) ) +
				AddPadding( string( groupedProgressData.startProgress ) ) +
				AddPadding( string( groupedProgressData.endProgress ) ) +
				AddPadding( string( groupedProgressData.goalProgress ) ) +
				AddPadding( string( groupedProgressData.isTierCompleted ) ) +
				AddPadding( string( groupedProgressData.isEventChallenge ) ) +
				AddPadding( string( groupedProgressData.isEventMain ) ) +
				ItemFlavor_GetHumanReadableRef( groupedProgressData.challengeFlav ) )
			}
		}
	#endif

	return progressDataArray
}
#endif

#if(UI)
int function GetRowsInChallengeProgressDataArray( array<ChallengeProgressData> progressDataArray )
{
	int rowCount
	foreach ( ChallengeProgressData progressData in progressDataArray )
	{
		rowCount++
		foreach ( int index, ChallengeProgressData groupedProgressData in progressData.groupArray )
		{
			rowCount++
		}
	}
	return rowCount
}
#endif

#if(UI)
int function PostMatchChallengeSort( ChallengeProgressData a, ChallengeProgressData b )
{
	//
	//
	//

	//
	if ( !a.isEventChallenge && b.isEventChallenge )
		return 1
	else if ( a.isEventChallenge && !b.isEventChallenge )
		return -1

	//
	if ( a.isEventMain && !b.isEventMain )
		return 1
	else if ( !a.isEventMain && b.isEventMain )
		return -1

	//
	if ( a.isPinned && !b.isPinned )
		return -1
	else if ( !a.isPinned && b.isPinned )
		return 1

	//
	if ( !a.isTierCompleted && b.isTierCompleted )
		return 1
	else if ( a.isTierCompleted && !b.isTierCompleted )
		return -1

	//
	if ( a.groupArray.len() != 0 && b.groupArray.len() == 0 )
		return 1
	else if ( a.groupArray.len() == 0 && b.groupArray.len() != 0 )
		return -1

	//
	//
	//
	//
	//
	//
	//

	//
	float a_ProgressFrac = float( a.endProgress - a.startProgress ) / float( a.goalProgress - a.startProgress )
	float b_ProgressFrac = float( b.endProgress - b.startProgress ) / float( b.goalProgress - b.startProgress )
	if ( a_ProgressFrac < b_ProgressFrac )
		return 1
	else if ( a_ProgressFrac > b_ProgressFrac )
		return -1

	//
	return 0
}

#endif

#if(UI)
int function ConvertSecondsToMinutes( int seconds )
{
	return int(float( seconds ) / 60.0)
}
#endif


#if(DEV)
string function AddPadding( string str, int minWidth = 8 )
{
	int len = str.len()
	while ( len < minWidth )
	{
		str = str + " "
		len++
	}
	return str
}
#endif

#if CLIENT || UI 
int function Challenge_GetCurrentTier( entity player, ItemFlavor flavor )
{
	#if(DEV)
		if ( DEV_ShouldIgnorePersistence() )
			return 0
	#endif
	//
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( flavor in pcs.challengeStateMap, "Called Challenge_GetCurrentTier for challenge " + ItemFlavor_GetHumanReadableRef( flavor ) + " but it was not assigned to the player " + string(player) )
	ChallengeState cs = pcs.challengeStateMap[flavor]
	return player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
}
#endif

#if CLIENT || UI 
bool function Challenge_IsAssigned( entity player, ItemFlavor flavor )
{
	//
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}
#endif

#if CLIENT || UI 
bool function Challenge_IsComplete( entity player, ItemFlavor flavor )
{
	int currentTier = Challenge_GetCurrentTier( player, flavor )
	int tierCount   = Challenge_GetTierCount( flavor )
	Assert( currentTier <= tierCount )
	return (currentTier == tierCount)
}
#endif


#if CLIENT || UI 
int function Challenge_GetTierCount( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	var settingsBlock = ItemFlavor_GetSettingsBlock( flavor )
	return GetSettingsArraySize( GetSettingsBlockArray( settingsBlock, "tiers" ) )
}
#endif

#if CLIENT || UI 
int function Challenge_GetTierCompletionsAtProgress( ItemFlavor flavor, int progress )
{
	Assert( Challenge_LastTierIsInfinite( flavor ), "don't call this with non infinite challenges" )

	int remainingProgress = progress
	int tierCount         = Challenge_GetTierCount( flavor )
	int completions       = 0
	int currentTier       = 0
	int goalVal           = 0

	while( remainingProgress > 0 )
	{
		if ( (currentTier + 1) == tierCount )
			goalVal += Challenge_GetGoalVal( flavor, currentTier )
		else
			goalVal = Challenge_GetGoalVal( flavor, currentTier )

		if ( goalVal > progress )
			break

		completions++

		currentTier++
		if ( currentTier == tierCount )
			currentTier = currentTier - 1
	}

	return completions
}
#endif

#if CLIENT || UI 
int function Challenge_GetProgressToCompleteChallengeNumTimes( ItemFlavor flavor, int tierCompletions )
{
	Assert( Challenge_LastTierIsInfinite( flavor ), "don't call this with non infinite challenges" )

	int requiredProgress = 0
	int tierCount        = Challenge_GetTierCount( flavor )
	int currentTier      = 0

	for ( int index = 0; index < tierCompletions; index++ )
	{
		int goalVal = Challenge_GetGoalVal( flavor, currentTier )
		if ( (currentTier + 1) == tierCount )
			requiredProgress += goalVal
		else
			requiredProgress = goalVal

		currentTier++
		if ( currentTier == tierCount )
			currentTier = currentTier - 1
	}

	return requiredProgress
}
#endif

#if CLIENT || UI 
int function Challenge_GetTimeSpanKind( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "timeSpan" )
	Assert( key in eChallengeTimeSpanKind, format( "Challenge %s has invalid time span kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeTimeSpanKind[key]
}
#endif


#if CLIENT || UI 
bool function Challenge_IsSingleMatch( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
	return GetSettingsBlockBool( tierData, "inSingleMatch" )
}
#endif


#if CLIENT || UI 
array<ItemFlavor> function Challenge_GetCharacterItemFlavors( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierBlock = Challenge_GetTierDataBlock( flavor, tier )

	array<ItemFlavor> characters = []
	var charactersArray          = GetSettingsBlockArray( tierBlock, "characters" )
	foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
	{
		asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
		if ( IsValidItemFlavorSettingsAsset( characterAsset ) )
			characters.append( GetItemFlavorByAsset( characterAsset ) )
	}

	return characters
}
#endif


#if CLIENT || UI 
ItemFlavor ornull function Challenge_GetWeaponItemFlavorOrNull( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData      = Challenge_GetTierDataBlock( flavor, tier )
	asset weaponAsset = GetSettingsBlockAsset( tierData, "weapon" )
	if ( IsValidItemFlavorSettingsAsset( weaponAsset ) )
		return GetItemFlavorByAsset( weaponAsset )
	return null
}
#endif


#if CLIENT || UI 
int function Challenge_GetGoalVal( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	int override = GetCurrentPlaylistVarInt( format( "%s_goal_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 )
	if ( override > -1 )
		return override

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
	return GetSettingsBlockInt( tierData, "goalVal" )
}
#endif

#if CLIENT || UI 
int function Challenge_GetGoalDisplayVal( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	int val = Challenge_GetGoalVal( flavor, tier )

	var tierData                 = Challenge_GetTierDataBlock( flavor, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}
#endif

#if CLIENT || UI 
string function Challenge_GetGRXRewardSequenceRef( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxRewardSequenceRef" )
}
#endif


#if CLIENT || UI 
int function Challenge_GetBPGrindPointsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int points = Voucher_GetEffectBattlepassGrindPoints( rewardFlav )
		if ( points <= 0 )
			continue

		total += points * rewards.quantities[rewardIdx]
	}
	return total
}
#endif

#if CLIENT || UI 
int function Challenge_GetBPStarsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int points = Voucher_GetEffectBattlepassStars( rewardFlav )
		if ( points <= 0 )
			continue

		total += points * rewards.quantities[rewardIdx]
	}
	return total
}
#endif

#if CLIENT || UI 
int function Challenge_GetBattlepassLevelsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int levels = Voucher_GetEffectBattlepassLevels( rewardFlav )
		if ( levels <= 0 )
			continue

		total += levels * rewards.quantities[rewardIdx]
	}
	return total
}
#endif


#if CLIENT || UI 
ItemFlavorBag function Challenge_GetRewards( ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, tier )

	ItemFlavorBag rewards
	foreach ( int rewardIdx, var rewardData in IterateSettingsArray( GetSettingsBlockArray( tierData, "rewards" ) ) )
	{
		asset rewardAsset = GetSettingsBlockAsset( rewardData, "flavor" )
		if ( !IsValidItemFlavorSettingsAsset( rewardAsset ) )
		{
			Warning( "Skipping item reward #%d of challenge '%s' because the asset is not a valid item flavor: '%s'", rewardIdx, ItemFlavor_GetHumanReadableRef( challengeFlav ), string(rewardAsset) )
			continue
		}

		rewards.flavors.append( GetItemFlavorByAsset( rewardAsset ) )
		rewards.quantities.append( GetSettingsBlockInt( rewardData, "quantity" ) )
	}
	return rewards
}
#endif


#if CLIENT || UI 
bool function Challenge_LastTierIsInfinite( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "lastTierIsInfinite" )
}
#endif


#if(UI)
bool function Challenge_IsPinned( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "pinned" )
}
#endif

#if(UI)
bool function Challenge_ShouldExcludeFromPostMatchSummary( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "excludeFromPostMatchSummary" )
}
#endif


#if CLIENT || UI 
int function Challenge_GetWeekNumber( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsInt( ItemFlavor_GetAsset( flavor ), "weekNumber" )
}
#endif


#if CLIENT || UI 
int function Challenge_GetTimeSpan( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return eChallengeTimeSpanKind[GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "timeSpan" )]
}
#endif


#if CLIENT || UI 
int function Challenge_GetProgressValue( entity player, ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	#if(DEV)
		if ( DEV_ShouldIgnorePersistence() )
			return 0
	#endif

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( challengeFlav in pcs.challengeStateMap, "Called Challenge_GetActiveTier for challenge " + ItemFlavor_GetHumanReadableRef( challengeFlav ) + " but it was not assigned to the player " + player )
	ChallengeState cs = pcs.challengeStateMap[challengeFlav]

	int goalVal = Challenge_GetGoalVal( challengeFlav, tier )

	int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )

	//
	if ( tier < currentTier )
		return goalVal

	//
	if ( tier > currentTier )
		return 0

	int current            = 0
	array<string> statRefs = Challenge_GetStatRefs( challengeFlav, tier )
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )
		current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
	}

	int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

	//
	//

	int progress = current - marker

	if ( progress < 0 )
		return 0

	if ( progress > goalVal )
		return goalVal

	return progress
}
#endif

#if(UI)
int function GetStarChallengeProgressStartLastMatch( entity player, ItemFlavor activeBattlePass )
{
	ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )
	Assert( starChallenge != null )
	expect ItemFlavor( starChallenge )

	int tier = 0 //

	Assert( ItemFlavor_GetType( starChallenge ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( starChallenge ) )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( starChallenge in pcs.challengeStateMap, "Called Challenge_GetActiveTier for challenge " + ItemFlavor_GetHumanReadableRef( starChallenge ) + " but it was not assigned to the player " + player )
	ChallengeState cs = pcs.challengeStateMap[starChallenge]

	int goalVal = Challenge_GetGoalVal( starChallenge, tier )

	int previous = 0
	array<string> statRefs = Challenge_GetStatRefs( starChallenge, tier )
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )
		previous += GetStat_Int( player, entry, eStatGetWhen.START_OF_PREVIOUS_MATCH )
	}

	int marker   = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )
	while ( marker > previous )
	{
		//
		marker -= goalVal
	}

	int progress = previous - marker
	Assert( progress >= 0 )

	return progress
}
#endif

#if CLIENT || UI 
int function Challenge_GetProgressDisplayValue( entity player, ItemFlavor challengeFlav, int tier )
{
	int val = Challenge_GetProgressValue( player, challengeFlav, tier )

	var tierData                 = Challenge_GetTierDataBlock( challengeFlav, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}
#endif

#if CLIENT || UI 
ItemFlavor function Challenge_GetSource( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	return fileLevel.challengeSourceMap[challengeFlav]
}
#endif


#if CLIENT || UI 
var function Challenge_GetTierDataBlock( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var settingsBlock      = ItemFlavor_GetSettingsBlock( flavor )
	var tierDataBlockArray = GetSettingsBlockArray( settingsBlock, "tiers" )

	return GetSettingsArrayElem( tierDataBlockArray, tier )
}
#endif


#if CLIENT || UI 
array<string> function Challenge_GetStatRefs( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	string specifiedStatRef = GetSettingsBlockString( tierData, "statRef" )
	array<string> statRefs  = []

	if ( specifiedStatRef.find( "%char%" ) > -1 )
	{
		array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( flavor, tier )
		Assert( characterFlavors.len() > 0, format( "Challenge %s tier %i uses char stat ref but doesn't have a character flavor associated with it", ItemFlavor_GetHumanReadableRef( flavor ), tier ) )
		foreach ( ItemFlavor character in characterFlavors )
		{
			statRefs.append( StringReplace( specifiedStatRef, "%char%", ItemFlavor_GetGUIDString( character ) ) )
		}
	}
	else if ( specifiedStatRef.find( "%weap%" ) > -1 )
	{
		ItemFlavor ornull weapon = Challenge_GetWeaponItemFlavorOrNull( flavor, tier )
		Assert( weapon != null, format( "Challenge %s tier %i uses weap stat ref but doesn't have a weapon flavor associated with it", ItemFlavor_GetHumanReadableRef( flavor ), tier ) )
		statRefs.append( StringReplace( specifiedStatRef, "%weap%", ItemFlavor_GetGUIDString( expect ItemFlavor( weapon ) ) ) )
	}
	else
	{
		statRefs.append( specifiedStatRef )
	}

	return statRefs
}
#endif

#if CLIENT || UI 
int function Challenge_GetDifficulty( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "difficulty" )
	Assert( key in eChallegeDifficulty, format( "Challenge %s has invalid difficulty kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallegeDifficulty[key]
}
#endif

#if CLIENT || UI 
bool function Challenge_ShouldStartAtZero( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockBool( tierData, "startAtZero" ) //
}
#endif


#if CLIENT || UI 
bool function Challenge_ShouldAddProgressFromPrevTier( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockBool( tierData, "addProgressFromPrevTier" )
}
#endif


#if CLIENT || UI 
string function Challenge_GetZoneName( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
	return GetSettingsBlockString( tierData, "zoneName" )
}
#endif


#if CLIENT || UI 
bool function Challenge_IsPremium( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isPremium" )
}
#endif


#if(UI)
ChallengeGroupData function CreateChallengeGroup( entity player, string nameString, array<ItemFlavor> challenges, int timeSpanKind )
{
	ChallengeGroupData group
	group.groupName = nameString
	group.challenges = challenges
	if ( player != null )
		group.completedChallenges = GetCompletedChallengeCount( player, challenges )
	group.timeSpanKind = timeSpanKind
	return group
}
#endif


#if CLIENT || UI 
int function GetCompletedChallengeCount( entity player, array<ItemFlavor> challenges )
{
	int count = 0

	foreach ( ItemFlavor challenge in challenges )
	{
		int maxTier = Challenge_GetTierCount( challenge ) - 1
		Assert( maxTier >= 0 )
		if ( IsChallengeTierComplete( player, challenge, maxTier ) )
			count++
	}

	return count
}
#endif


#if(UI)
void function RefreshChallenges()
{
	if ( CanRunClientScript() )
		RunClientScript( "ServerToClient_AssignedChallengesDidChange_FromEventsRefresh" )
}
#endif


#if(false)












//










#endif


#if(false)


























#endif


